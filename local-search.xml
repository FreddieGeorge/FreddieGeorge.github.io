<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>qt4与qt5中QString::compare方法差异</title>
    <link href="/2024/10/23/qt4%E4%B8%8Eqt5%E4%B8%ADQStrin%20compare%E6%96%B9%E6%B3%95%E5%B7%AE%E5%BC%82/"/>
    <url>/2024/10/23/qt4%E4%B8%8Eqt5%E4%B8%ADQStrin%20compare%E6%96%B9%E6%B3%95%E5%B7%AE%E5%BC%82/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>隔壁组的同事在调试qt代码的时候遇到了一个bug，该bug发生前的代码大致如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 比较用户输入的密码与dv123456是否一致</span><br><span class="hljs-type">int</span> match = QString::<span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;dv123456&quot;</span>,<span class="hljs-built_in">userInputPwd</span>());<br><span class="hljs-comment">// 一致则解锁</span><br><span class="hljs-keyword">if</span>(match == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">/* unlock */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该段代码一直运行正常</p><p>后面另一个同事为了增加另一个密码兼容，增加了如下代码</p><blockquote><p>这里的代码写法肯定有问题的，不能使用&amp;&#x3D;符，直接两个compare结果单独判断是否为零即可</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 比较用户输入的密码与dv123456或者412345是否一致</span><br><span class="hljs-type">int</span> match = QString::<span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;dv123456&quot;</span>,<span class="hljs-built_in">userInputPwd</span>());<br>match &amp;= QString::<span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;412345&quot;</span>,<span class="hljs-built_in">userInputPwd</span>());<br><span class="hljs-comment">// 一致则解锁</span><br><span class="hljs-keyword">if</span>(match == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">/* unlock */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>大部分情况下该代码可以正常运行，但是今天发现如果用户输入<code>dv123456</code>的前几个字符，或者<code>412345</code>的前几个字符,比如<code>d</code>,<code>4</code>,则一样会进入<code>match == 0</code>部分代码。</p><p>我刚好在旁边看着这个bug的触发，调出了qt的源码查看QString部分的源码查看compare实现</p><h2 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h2><h3 id="qt4-compare实现"><a href="#qt4-compare实现" class="headerlink" title="qt4 compare实现"></a>qt4 compare实现</h3><p>由于我们组的芯片方案SDK中用的是qt4.8.6,所以我打开的是qt4源码中的compare实现，代码截取如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QString::compare</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;other)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ucstrcmp</span>(<span class="hljs-built_in">constData</span>(), <span class="hljs-built_in">length</span>(), other.<span class="hljs-built_in">constData</span>(), other.<span class="hljs-built_in">length</span>());<br>&#125;<br><span class="hljs-comment">// 设置了大小写敏感进入该函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QString::compare</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;other, Qt::CaseSensitivity cs)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cs == Qt::CaseSensitive)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ucstrcmp</span>(<span class="hljs-built_in">constData</span>(), <span class="hljs-built_in">length</span>(), other.<span class="hljs-built_in">constData</span>(), other.<span class="hljs-built_in">length</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">ucstricmp</span>(d-&gt;data, d-&gt;data + d-&gt;size, other.d-&gt;data, other.d-&gt;data + other.d-&gt;size);<br>&#125;<br><br><br><span class="hljs-comment">// Unicode case-sensitive comparison</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">ucstrcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> QChar *a, <span class="hljs-type">int</span> alen, <span class="hljs-type">const</span> QChar *b, <span class="hljs-type">int</span> blen)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a == b &amp;&amp; alen == blen)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> l = <span class="hljs-built_in">qMin</span>(alen, blen);<br>    <span class="hljs-type">int</span> cmp = <span class="hljs-built_in">ucstrncmp</span>(a, b, l);<br>    <span class="hljs-keyword">return</span> cmp ? cmp : (alen-blen);<br>&#125;<br><br><span class="hljs-comment">// Unicode case-sensitive compare two same-sized strings</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">ucstrncmp</span><span class="hljs-params">(<span class="hljs-type">const</span> QChar *a, <span class="hljs-type">const</span> QChar *b, <span class="hljs-type">int</span> l)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l-- &amp;&amp; *a == *b)<br>        a++,b++;<br>    <span class="hljs-keyword">if</span> (l==<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> a-&gt;<span class="hljs-built_in">unicode</span>() - b-&gt;<span class="hljs-built_in">unicode</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>qt4中这个compare的实现还是比较简单易懂的，在调用<code>compare(a,b)</code>的时候，只会比较较短字符串的长度。如果遍历完成后都相同，则返回a和b的长度差，如果有不同，则返回不同字符的unicode代码差值</p><p>以<code>compare(&quot;dv123456&quot;,&quot;dv&quot;)</code>为例<code>ucstrncmp</code>中<code>l</code>为2,在while循环中遍历完后可以看到长度为2的子串都是相等的，那么<code>ucstrncmp</code>将会返回0，<code>ucstrcmp</code>则会返回<code>alen-blen</code>,最终返回应该是4。</p><p>而如果是<code>compare(&quot;412345&quot;,&quot;dv&quot;)</code>,在while中无法遍历完成，最终<code>ucstrncmp</code>将会返回4和d的ascii码差值，查表可知4的ascii码十进制是52，d为100，最后应该是-48</p><h3 id="实际验证"><a href="#实际验证" class="headerlink" title="实际验证"></a>实际验证</h3><p>为了验证该推论，在上述bug代码中增加打印如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 比较用户输入的密码与dv123456是否一致</span><br><span class="hljs-type">int</span> match1 = QString::<span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;dv123456&quot;</span>,<span class="hljs-built_in">userInputPwd</span>());<br><span class="hljs-type">int</span> match2 = QString::<span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;412345&quot;</span>,<span class="hljs-built_in">userInputPwd</span>());<br><span class="hljs-type">int</span> match = match11 &amp; match2;<br><span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;match1 = &quot;</span> &lt;&lt; match1;<br><span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;match2 = &quot;</span> &lt;&lt; match2;<br><span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;match  = &quot;</span> &lt;&lt; match;<br><span class="hljs-comment">// 一致则解锁</span><br><span class="hljs-keyword">if</span>(match == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">/* unlock */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在输入框输入dv后，打印结果却有所出入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">match1 = <span class="hljs-number">1</span><br>match2 = <span class="hljs-number">-48</span><br>match  = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>首先match为0则是因为1的二进制与-48的二进制刚好是0，则会误进入unlock代码段中。而match1是1则让我百思不得其解，而我手动在我的qt4环境中写了demo打印发现确实应该是4和-48，demo如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QCoreApplication <span class="hljs-title">a</span><span class="hljs-params">(argc, argv)</span></span>;<br>    QString s1 = <span class="hljs-string">&quot;dv123456&quot;</span>;<br>    QString s2 = <span class="hljs-string">&quot;412345&quot;</span>;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>    QString test = <span class="hljs-string">&quot;dv&quot;</span>;  <span class="hljs-comment">// s1: ret = 4</span><br>                          <span class="hljs-comment">// s2: ret = -48</span><br><br>    ret = QString::<span class="hljs-built_in">compare</span>(s1,test);<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;s1: ret = &quot;</span> &lt;&lt; ret;<br><br>    ret = QString::<span class="hljs-built_in">compare</span>(s2,test);<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;s2: ret = &quot;</span> &lt;&lt; ret;<br><br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="qt5-compare实现"><a href="#qt5-compare实现" class="headerlink" title="qt5 compare实现"></a>qt5 compare实现</h3><p>后面与同事沟通发现，他们那款芯片的sdk采用的是Qt5，于是我猜测是compare在qt4和qt5的实现不一致，于是拉下一个qt5的源码查看，截取如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">QString::compare</span><span class="hljs-params">(<span class="hljs-type">const</span> QString &amp;other, Qt::CaseSensitivity cs)</span> <span class="hljs-type">const</span> Q_DECL_NOTHROW</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">qt_compare_strings</span>(*<span class="hljs-keyword">this</span>, other, cs);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">qt_compare_strings</span><span class="hljs-params">(QStringView lhs, QStringView rhs, Qt::CaseSensitivity cs)</span> Q_DECL_NOTHROW</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cs == Qt::CaseSensitive)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ucstrcmp</span>(lhs.<span class="hljs-built_in">begin</span>(), lhs.<span class="hljs-built_in">size</span>(), rhs.<span class="hljs-built_in">begin</span>(), rhs.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ucstricmp</span>(lhs.<span class="hljs-built_in">begin</span>(), lhs.<span class="hljs-built_in">end</span>(), rhs.<span class="hljs-built_in">begin</span>(), rhs.<span class="hljs-built_in">end</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">ucstrcmp</span><span class="hljs-params">(<span class="hljs-type">const</span> QChar *a, <span class="hljs-type">size_t</span> alen, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *b, <span class="hljs-type">size_t</span> blen)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> l = <span class="hljs-built_in">qMin</span>(alen, blen);<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> cmp = <span class="hljs-built_in">ucstrncmp</span>(a, <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> uchar*&gt;(b), l);<br>    <span class="hljs-keyword">return</span> cmp ? cmp : <span class="hljs-built_in">lencmp</span>(alen, blen);<br>&#125;<br><br><span class="hljs-comment">// Unicode case-sensitive compare two same-sized strings</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">ucstrncmp</span><span class="hljs-params">(<span class="hljs-type">const</span> QChar *a, <span class="hljs-type">const</span> QChar *b, <span class="hljs-type">size_t</span> l)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* 代码过长，不截取 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到前面几部分代码基本逻辑相同，在<code>ucstrncmp</code>也只是增加了许多平台优化相关，qt4和qt5最大的差别在于ucstrcmp的return语句。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// qt4</span><br><span class="hljs-keyword">return</span> cmp ? cmp : (alen-blen);<br><br><span class="hljs-comment">// qt5</span><br><span class="hljs-keyword">return</span> cmp ? cmp : <span class="hljs-built_in">lencmp</span>(alen, blen);<br><br><span class="hljs-function">Q_DECL_CONSTEXPR <span class="hljs-type">int</span> <span class="hljs-title">lencmp</span><span class="hljs-params">(Number lhs, Number rhs)</span> Q_DECL_NOTHROW</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> lhs == rhs ? <span class="hljs-number">0</span> :<br>           lhs &gt;  rhs ? <span class="hljs-number">1</span> :<br>           <span class="hljs-comment">/* else */</span>  <span class="hljs-number">-1</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到qt5中不再使用alen-blen的方式，而且返回0，1，-1表示<code>compare(a,b)</code>的字符串长短关系，a比b长则返回1，相等则为0，a比b短为-1。</p><p>这也就是造成了qt4和qt5中同一个方法的结果差异所在。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p><code>compare</code>函数设计更多是为了用于字符串排序的工作，这种判断字符串是否完全相等的情况应该直接使用<code>QString</code>重写的<code>==</code>运算符,返回bool更加方便做判断运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// qt4</span><br><span class="hljs-type">bool</span> QString::<span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> QString &amp;other) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (d-&gt;size != other.d-&gt;size)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">qMemEquals</span>(d-&gt;data, other.d-&gt;data, d-&gt;size);<br>&#125;<br><br><span class="hljs-comment">// qt5</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> QString &amp;s1, <span class="hljs-type">const</span> QString &amp;s2) Q_DECL_NOTHROW<br>&#123;<br>    <span class="hljs-keyword">if</span> (s1.d-&gt;size != s2.d-&gt;size)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">qt_compare_strings</span>(s1, s2, Qt::CaseSensitive) == <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发板与PC串口传输文件</title>
    <link href="/2023/07/04/%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8EPC%E4%B8%B2%E5%8F%A3%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/"/>
    <url>/2023/07/04/%E5%BC%80%E5%8F%91%E6%9D%BF%E4%B8%8EPC%E4%B8%B2%E5%8F%A3%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直以来我都以为串口这个速率无法传输文件，在与嵌入式通信的时候都是nfs，telnet之类的，这几个月我的USB转网口的模块还坏了，我一直在用sd卡传输文件，不堪其扰。这段时间才看到可以使用串口传输文件，总算是解放了。</p><blockquote><p>rz(resive z-modem)和sz(send z-modem)是比较古老的工具，而且速率较慢，自己测试传输的时候速率只有<code>20 kBPS</code>，只能传输小文件，这个应该是跟波特率有关，能使用nfs的话还是用nfs好一点。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/thisway_diy/article/details/109984270">韦东山老师的rz&#x2F;sz教程</a></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>如果在开发板中没有rz&#x2F;sz(lrz&#x2F;lsz)工具，那需要自己编译一个放进开发板中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">download <span class="hljs-built_in">source</span> code</span><br>wget https://www.ohse.de/uwe/releases/lrzsz-0.12.20.tar.gz<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">decompress</span> <br>tar -zxvf lrzsz-0.12.20.tar.gz<br></code></pre></td></tr></table></figure><p>进入解压出来的文件夹中，输入<code>./configure --prefix=$PWD/__install --host=aarch64-linux-gnu</code>，根据你的交叉编译工具链修改<code>--host</code>后面的内容</p><p>然后执行<code>make &amp;&amp; make install</code>即可在<code>./__install/bin</code>目录下看到编译好的工具，将他们放入开发板中即可。</p><h2 id="rz-PC向开发板发送文件"><a href="#rz-PC向开发板发送文件" class="headerlink" title="rz : PC向开发板发送文件"></a>rz : PC向开发板发送文件</h2><p>一般PC端的的串口软件都是支持rz发送文件给开发板的，我使用的<a href="https://mobaxterm.mobatek.net/">MobaXterm</a>。</p><p>通过串口连接开发板进入Linux系统之后，输入<code>rz</code>，开发板会等待PC端发送文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">[root@/]$ </span><span class="language-bash">rz</span><br>▒z waiting to receive.**B0100000023be50<br></code></pre></td></tr></table></figure><p>这个时候对着MobaXterm的终端界面右键(或者<code>ctrl</code>+<code>shift</code>+右键)就可以打开选择框，选择<code>Send file using Z-modem</code>就可以调用资源管理器向开发板传输文件了。</p><blockquote><p>我的MobaXterm右键是粘贴内容，所以需要<code>ctrl</code>+<code>shift</code>+右键才能打开选择框</p></blockquote><h2 id="sz-从开发板下载文件到PC"><a href="#sz-从开发板下载文件到PC" class="headerlink" title="sz : 从开发板下载文件到PC"></a>sz : 从开发板下载文件到PC</h2><p>在终端输入<code>sz &lt;file_to_send&gt;</code>之后就会进入发送模式等待PC接收文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">[root@/]$ </span><span class="language-bash">sz /root/algo/result.jpg</span><br>▒*B00000000000000<br></code></pre></td></tr></table></figure><p>这时候按照上面的方法打开MobaXterm的选择框，选择<code>Receive file using Z-modem</code>即可选择文件保存位置。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个方法只适用于小文件，大文件动辄20多分钟，谨慎使用</p><p>最后还是很少用串口传文件，太慢了，目前在使用<code>adb</code>，之后有机会出一篇博客。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全志平台rtl8188fu wifi模块开发</title>
    <link href="/2023/06/26/%E5%85%A8%E5%BF%97%E5%B9%B3%E5%8F%B0rtl8188fu-wifi%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/"/>
    <url>/2023/06/26/%E5%85%A8%E5%BF%97%E5%B9%B3%E5%8F%B0rtl8188fu-wifi%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好久没更新了，最近的活杂七杂八的，很多还很玄学。这段时间手里有个新板子需要调试，有很多杂七杂八的东西需要配置，主要是这个rtl8188fu比较有意思，这里将调试过程记录下来。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_41340733/article/details/109072685">全志A64wifi配置</a></p><p><a href="https://blog.csdn.net/weixin_43772810/article/details/121113707">全志A40i移植 RTL8188FTV&#x2F;RTL8188FU USB-WiFi</a></p><h2 id="编译驱动源码"><a href="#编译驱动源码" class="headerlink" title="编译驱动源码"></a>编译驱动源码</h2><p>我找到的rtl8188fu的驱动源码是<a href="https://github.com/ulli-kroll/rtl8188fu">ulli-kroll&#x2F;rtl8188fu</a>，输入以下命令编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- KSRC=/home/flork/T5_SDK/HD250_sdk_test/kernel/linux-4.9/ modules<br></code></pre></td></tr></table></figure><p>编译报错 <code>error: label at end of compound statement</code>,看了下源码报错位置后发现是因为源码中void的函数的lable后面没有内容，类似如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">/* ... */</span><br>    <span class="hljs-keyword">goto</span> <span class="hljs-built_in">exit</span>;<br><span class="hljs-built_in">exit</span>:<br>&#125;<br></code></pre></td></tr></table></figure><p>这在不同编译器里面可能会报错，本来想自己慢慢加的，在issue里面随手搜了一下，发现之前有人提过这个issue，并且提交过自己修改好的代码，但是应该是没有合并进去。那我直接拉下<a href="https://github.com/leandropecanhascardua/rtl8188fu/tree/correcting_error_exit_gcc_9_ubuntu">leandropecanhascardua&#x2F;rtl8188fu</a>即可直接使用。</p><p>至此编译KO文件成功</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>将生成的ko文件拷贝到板子上并安装驱动。</p><p>修改<code>/etc/wpa_supplicant.conf</code>,默认应该是STA模式，填入路由器的ssid和密码即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">ctrl_interface=/var/run/wpa_supplicant<br>ctrl_interface_group=<span class="hljs-number">0</span><br>ap_scan=<span class="hljs-number">1</span><br>update_config=<span class="hljs-number">1</span><br>network=&#123;<br>        ssid=<span class="hljs-string">&quot;Flork&quot;</span><br>        key_mgmt=WPA-PSK<br>        psk=<span class="hljs-string">&quot;xxxxxxxxxxx&quot;</span><br>        priority=<span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后执行<code>wpa_supplicant -Dnl80211 -iwlan0 -B -c /etc/wpa_supplicant.conf</code>,然后就能通过<code>ifconfig</code>看到wlan0的信息了。也可以通过<code>wpa_cli -i wlan0 status</code> 查看状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">wlan0     Link encap:Ethernet  HWaddr <span class="hljs-number">48</span>:<span class="hljs-number">8F</span>:<span class="hljs-number">4</span>C:<span class="hljs-number">42</span>:<span class="hljs-number">62</span>:<span class="hljs-number">05</span><br>          UP BROADCAST MULTICAST  MTU:<span class="hljs-number">1500</span>  Metric:<span class="hljs-number">1</span><br>          RX packets:<span class="hljs-number">0</span> errors:<span class="hljs-number">0</span> dropped:<span class="hljs-number">0</span> overruns:<span class="hljs-number">0</span> frame:<span class="hljs-number">0</span><br>          TX packets:<span class="hljs-number">0</span> errors:<span class="hljs-number">0</span> dropped:<span class="hljs-number">0</span> overruns:<span class="hljs-number">0</span> carrier:<span class="hljs-number">0</span><br>          collisions:<span class="hljs-number">0</span> txqueuelen:<span class="hljs-number">1000</span><br>          RX bytes:<span class="hljs-number">0</span> (<span class="hljs-number">0.0</span> B)  TX bytes:<span class="hljs-number">0</span> (<span class="hljs-number">0.0</span> B)<br></code></pre></td></tr></table></figure><!-- 此时可以发现还没有连接到网络，需要使用`hostapd -B /etc/hostapd.conf`命令 --><p>连接成功后执行<code>wpa_cli -i wlan0 status</code>会提示<code>wpa_state=COMPLETED</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">[root@/]$ wpa_cli -i wlan0 status<br>bssid=<span class="hljs-number">64</span>:<span class="hljs-number">09</span>:<span class="hljs-number">80</span>:<span class="hljs-number">18</span>:fe:<span class="hljs-number">2f</span><br>freq=<span class="hljs-number">2442</span><br>ssid=Flork<br>id=<span class="hljs-number">0</span><br>mode=station<br>pairwise_cipher=CCMP<br>group_cipher=TKIP<br>key_mgmt=WPA2-PSK<br>wpa_state=COMPLETED<br>address=<span class="hljs-number">48</span>:<span class="hljs-number">8f</span>:<span class="hljs-number">4</span>c:<span class="hljs-number">42</span>:<span class="hljs-number">62</span>:<span class="hljs-number">05</span><br></code></pre></td></tr></table></figure><p>此时仍然不能上网，因为还没分配ip地址，输入<code>udhcpc -i wlan0 &amp;</code>,等待路由器dhcp分配ip地址，然后成功ping通网络</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">[root@/]$ ping www.baidu.com<br>PING www.baidu.com (<span class="hljs-number">14.119</span><span class="hljs-number">.104</span><span class="hljs-number">.189</span>): <span class="hljs-number">56</span> data bytes<br><span class="hljs-number">64</span> bytes from <span class="hljs-number">14.119</span><span class="hljs-number">.104</span><span class="hljs-number">.189</span>: seq=<span class="hljs-number">3</span> ttl=<span class="hljs-number">54</span> time=<span class="hljs-number">36.461</span> ms<br><span class="hljs-number">64</span> bytes from <span class="hljs-number">14.119</span><span class="hljs-number">.104</span><span class="hljs-number">.189</span>: seq=<span class="hljs-number">4</span> ttl=<span class="hljs-number">54</span> time=<span class="hljs-number">111.119</span> ms<br><span class="hljs-number">64</span> bytes from <span class="hljs-number">14.119</span><span class="hljs-number">.104</span><span class="hljs-number">.189</span>: seq=<span class="hljs-number">5</span> ttl=<span class="hljs-number">54</span> time=<span class="hljs-number">83.867</span> ms<br><span class="hljs-number">64</span> bytes from <span class="hljs-number">14.119</span><span class="hljs-number">.104</span><span class="hljs-number">.189</span>: seq=<span class="hljs-number">6</span> ttl=<span class="hljs-number">54</span> time=<span class="hljs-number">29.746</span> ms<br><span class="hljs-number">64</span> bytes from <span class="hljs-number">14.119</span><span class="hljs-number">.104</span><span class="hljs-number">.189</span>: seq=<span class="hljs-number">7</span> ttl=<span class="hljs-number">54</span> time=<span class="hljs-number">46.891</span> ms<br><br></code></pre></td></tr></table></figure><p>至此wifi模块的基本调试完成</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>全志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>T507</tag>
      
      <tag>WiFi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美化github个人界面</title>
    <link href="/2023/04/06/%E7%BE%8E%E5%8C%96github%E4%B8%AA%E4%BA%BA%E7%95%8C%E9%9D%A2/"/>
    <url>/2023/04/06/%E7%BE%8E%E5%8C%96github%E4%B8%AA%E4%BA%BA%E7%95%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<!-- 又可以水一篇博客，美滋滋 --><!-- 拖更好久了，今天忙完项目填个坑 --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Github找开源代码的时候，看到了很多大佬漂亮的github界面。于是我决定我也搞一个。于是在周五下午，喝着公司的下午茶把自己的界面捣鼓了一下。<del>顺便把这篇博客给水了。</del></p><p>示例界面：<a href="https://github.com/FreddieGeorge">FreddieGeorge</a></p><h2 id="参考样例"><a href="#参考样例" class="headerlink" title="参考样例"></a>参考样例</h2><p>Github有个仓库叫<a href="https://github.com/kautukkundan/Awesome-Profile-README-templates">Awesome-Profile-README-templates</a>，收集了很多漂亮的Github界面，根据不同的种类按照文件夹分类了。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="新建profile仓库"><a href="#新建profile仓库" class="headerlink" title="新建profile仓库"></a>新建profile仓库</h3><p>首先需要一个仓库，名字与你的github用户名一致，这个仓库官方叫做profile repository。里面的 README.md 的内容就会展示在自己的profile上。</p><p>在github中新建一个仓库，命名为<code>FreddieGeorge</code>，那么这个就是我的profile repository。在新建仓库的时候勾选上add README.md,即可自动生成一个README.file。后面的文本需修改都是基于这个README.md来操作。</p><h3 id="添加waka-time代码统计"><a href="#添加waka-time代码统计" class="headerlink" title="添加waka-time代码统计"></a>添加waka-time代码统计</h3><p><a href="https://wakatime.com/dashboard">waka-time</a>是一个代码时间等统计的插件。我使用的代码编辑软件以VSCode为主，并且很早就安装好了waka-time的统计插件。所以我决定在自己的README中添加代码统计。具体参考了这篇<a href="https://blog.csdn.net/weixin_43233914/article/details/126087735">博客</a>。</p><p>在vscode的配置部分本文就不再赘述，只需要在插件商店搜索wakatime即可，安装方法网上也很多。接下来只讲github的配置部分</p><h4 id="添加Action-secret"><a href="#添加Action-secret" class="headerlink" title="添加Action secret"></a>添加Action secret</h4><p>进入profile仓库中，选择Settings -&gt; Secrets and variables -&gt; Actions -&gt; New repository secret,在Name中填写<code>WAKATIME_API_KEY</code>,value就是wakatime的API Key。</p><p>然后需要获取Github仓库的API令牌，点击右上角头像-&gt; Settings -&gt; Developer settings -&gt; Personal access tokens -&gt; Tokens(classic),填写好note，设置好过期时间Expiration,然后权限选择repo和user，最后点击Generate token生成令牌，并将生成的令牌复制好</p><p>然后就可以再次来到profile仓库中进入新建 repository secret的地方，再新建一个secret，Name设置为<code>GH_TOKEN</code>,value就是刚刚复制的令牌。</p><p>至此Action secret配置完成。</p><h4 id="添加workflows"><a href="#添加workflows" class="headerlink" title="添加workflows"></a>添加workflows</h4><p>接下来就需要添加一个让README.md能够每天自动刷新。workflow的文档在<a href="https://docs.github.com/en/actions/using-workflows/about-workflows">github官网</a>可以找到</p><p>workflows的模板大概是</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Waka</span> <span class="hljs-string">Readme</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">workflow_dispatch:</span> <span class="hljs-comment"># for manual workflow trigger</span><br>  <span class="hljs-attr">schedule:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">cron:</span> <span class="hljs-string">&quot;0 0 * * *&quot;</span> <span class="hljs-comment"># runs at every 12AM UTC</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">update-readme:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">WakaReadme</span> <span class="hljs-string">DevMetrics</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">anmol098/waka-readme-stats@master</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">WAKATIME_API_KEY:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.WAKATIME_API_KEY</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">GH_TOKEN:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GH_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-comment"># 自定义部分</span><br></code></pre></td></tr></table></figure><p>使用的Action仓库是<a href="https://github.com/anmol098/waka-readme-stats">athul&#x2F;waka-readme</a>。看官方README可以知道不同的flag有不同的含义，我这里挑了比较主要的部分作了一个简单的翻译或者自己的介绍。详细还是以官方README为准</p><table><thead><tr><th align="center">Flag</th><th align="center">默认</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>LOCALE</code></td><td align="center"><code>en</code></td><td align="center">使用的语言，键值根据<a href="https://saimana.com/list-of-country-locale-code/">Short Hand</a>得到</td></tr><tr><td align="center"><code>SECTION_NAME</code></td><td align="center"><code>&quot;waka&quot;</code></td><td align="center">这是用来寻找何处插入waka统计的匹配字符，后续会提到</td></tr><tr><td align="center"><code>SHOW_UPDATED_DATE</code></td><td align="center"><code>&quot;False&quot;</code></td><td align="center">是否在图表末尾显示更新时间</td></tr><tr><td align="center"><code>SHOW_LINES_OF_CODE</code></td><td align="center"><code>&quot;Flase&quot;</code></td><td align="center">是否显示总共写的代码行数</td></tr><tr><td align="center"><code>SHOW_TOTAL_CODE_TIME</code></td><td align="center"><code>&quot;True&quot;</code></td><td align="center">是否显示总共写的代码时间</td></tr><tr><td align="center"><code>SHOW_PROFILE_VIEWS</code></td><td align="center"><code>&quot;True&quot;</code></td><td align="center">是否显示profile的浏览量</td></tr><tr><td align="center"><code>SHOW_COMMIT</code></td><td align="center"><code>&quot;True&quot;</code></td><td align="center">是否显示commit时间段</td></tr><tr><td align="center"><code>SHOW_DAYS_OF_WEEK</code></td><td align="center"><code>&quot;True&quot;</code></td><td align="center">是否统计在周一到周日各天的commit次数</td></tr><tr><td align="center"><code>SHOW_LANGUAGE</code></td><td align="center"><code>&quot;True&quot;</code></td><td align="center">是否显示使用语言的时长</td></tr><tr><td align="center"><code>SHOW_OS</code></td><td align="center"><code>&quot;True&quot;</code></td><td align="center">是否显示使用操作系统时长</td></tr><tr><td align="center"><code>SHOW_PROJECTS</code></td><td align="center"><code>&quot;True&quot;</code></td><td align="center">是否统计不同项目的工作时长</td></tr><tr><td align="center"><code>SHOW_EDITORS</code></td><td align="center"><code>&quot;True&quot;</code></td><td align="center">是否显示编辑器</td></tr><tr><td align="center"><code>SYMBOL_VERSION</code></td><td align="center"><code>1</code></td><td align="center">进度条的填充符号选择</td></tr></tbody></table><p>我的配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Waka</span> <span class="hljs-string">Readme</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">workflow_dispatch:</span> <span class="hljs-comment"># for manual workflow trigger</span><br>  <span class="hljs-attr">schedule:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">cron:</span> <span class="hljs-string">&quot;0 0 * * *&quot;</span> <span class="hljs-comment"># runs at every 12AM UTC</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">update-readme:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">WakaReadme</span> <span class="hljs-string">DevMetrics</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">anmol098/waka-readme-stats@master</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">WAKATIME_API_KEY:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.WAKATIME_API_KEY</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">GH_TOKEN:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GH_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">TIME_RANGE:</span> <span class="hljs-string">last_30_days</span><br>          <span class="hljs-attr">SHOW_LINES_OF_CODE:</span> <span class="hljs-string">&quot;True&quot;</span><br>          <span class="hljs-attr">SHOW_PROFILE_VIEWS:</span> <span class="hljs-string">&quot;False&quot;</span><br>          <span class="hljs-attr">SHOW_COMMIT:</span> <span class="hljs-string">&quot;False&quot;</span><br>          <span class="hljs-attr">SHOW_EDITORS:</span> <span class="hljs-string">&quot;False&quot;</span><br>          <span class="hljs-attr">SHOW_DAYS_OF_WEEK:</span> <span class="hljs-string">&quot;False&quot;</span><br>          <span class="hljs-attr">SHOW_LANGUAGE:</span> <span class="hljs-string">&quot;True&quot;</span><br>          <span class="hljs-attr">SHOW_OS:</span> <span class="hljs-string">&quot;True&quot;</span><br>          <span class="hljs-attr">SHOW_PROJECTS:</span> <span class="hljs-string">&quot;False&quot;</span><br>          <span class="hljs-attr">SHOW_TIMEZONE:</span> <span class="hljs-string">&quot;False&quot;</span><br>          <span class="hljs-attr">SHOW_LANGUAGE_PER_REPO:</span> <span class="hljs-string">&quot;False&quot;</span><br>          <span class="hljs-attr">SHOW_SHORT_INFO:</span> <span class="hljs-string">&quot;False&quot;</span><br>          <span class="hljs-attr">SHOW_LOC_CHART:</span> <span class="hljs-string">&quot;False&quot;</span><br>          <span class="hljs-comment"># SYMBOL_VERSION: 1 get graph like  this</span><br><br>          <span class="hljs-comment">#  ██████████░░░░░░░░░░░░░░░ </span><br>          <span class="hljs-attr">SYMBOL_VERSION:</span> <span class="hljs-number">2</span><br><br></code></pre></td></tr></table></figure><h4 id="README中添加"><a href="#README中添加" class="headerlink" title="README中添加"></a>README中添加</h4><p>在README中需要插入waka统计的地方加上两行代码即可，其中<code>waka</code>就是<code>SECTION_NAME</code>指定的字符</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--START_SECTION:waka--&gt;</span><br><span class="hljs-comment">&lt;!--END_SECTION:waka--&gt;</span><br></code></pre></td></tr></table></figure><h3 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h3><p>经常能看到一些profile有各种各样的图标，比如<a href="https://github.com/nonebot/nonebot2">NoneBot</a>的README开头的一大堆图标。这些都是在<a href="https://shields.io/">shields.io</a>中能找到，包括语言，下载数等，都可以在这个网站生成。在很多仓库中都可以看到这种图标。</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全志T5的LVDS调试记录</title>
    <link href="/2023/03/30/%E5%85%A8%E5%BF%97T5%E7%9A%84LVDS%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/03/30/%E5%85%A8%E5%BF%97T5%E7%9A%84LVDS%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这段时间都在忙着全志T507的LVDS调试，最后发现了好多的坑点，虽然最后验证出来是不可行的，但是也还是写一下自己的调试过程和心得吧。</p><p>这个调试任务是因为我们需要使用两路lvds输出，一路输出lcd屏，一路需要输出给一个转换芯片，芯片需要输入标准的1080p30，720p30的信号。</p><p>LCD的调试倒是简单，对着datasheet调一下前后肩，dclk等就可以了。难点在第二路输出。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://m.elecfans.com/article/1810889.html">全志T5同显</a></p><p><a href="https://www.cnblogs.com/yiguobei99/p/4033919.html">android4.0 A10开发板，如何实现分屏（多屏幕显示）不同的内容</a></p><p><a href="https://whycan.com/files/201803/A10%20LCD%e8%b0%83%e8%af%95%e6%89%8b%e5%86%8cV1.0.pdf">A10 LCD调试手册</a></p><p><a href="https://blog.csdn.net/wangtianxu2008/article/details/79151666">全志同显</a></p><p><a href="https://whycan.com/files/202108/d1/D1_Linux_LCD_%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97.pdf">全志D1 LCD调试指南</a></p><p><a href="https://cloud.tencent.com/developer/article/2201313">全志Tina Linux LCD显示屏调试指南</a></p><h2 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h2><p>在全志的sdk中，主要关系到lvds输出的是两个部分，一个是disp，一个是lcd</p><p>他们大部分都是有注释的，可以直接查阅注释知道具体意思，也可以看几个参考资料，都写得比较齐全，这次的重点不在这边，便不多赘述。</p><p>lcd部分中，需要注意的是<code>lcd_dclk_freq</code>，这个是lvds的dclk频率，单位是<strong>MHz</strong>,只能是整数。</p><p>从这个表格中我们可以算到，如果要输出1080p30,720p30的图像，则需要74.25MHz和37.125MHz的dclk</p><blockquote><table><thead><tr><th align="center">制式</th><th align="center">总扫描线</th><th align="center">图像区域扫描线</th><th align="center">水平总像素</th><th align="center">图像区域水平像素</th><th align="center">采样频率</th></tr></thead><tbody><tr><td align="center">1080P60</td><td align="center">1125</td><td align="center">1080</td><td align="center">2200</td><td align="center">1920</td><td align="center">148.5MHz</td></tr><tr><td align="center">1080P50</td><td align="center">1125</td><td align="center">1080</td><td align="center">2640</td><td align="center">1920</td><td align="center">148.5MHz</td></tr><tr><td align="center">720P60</td><td align="center">750</td><td align="center">720</td><td align="center">1650</td><td align="center">1280</td><td align="center">74.25MHz</td></tr><tr><td align="center">720P50</td><td align="center">750</td><td align="center">720</td><td align="center">1980</td><td align="center">1280</td><td align="center">74.25MHz</td></tr></tbody></table></blockquote><p>当前驱动无法满足我们的需求。故我们需要更改disp的驱动源码，将<code>lcd_dclk_freq</code>的单位改为kHz。</p><h2 id="更改lcd-dclk-freq单位"><a href="#更改lcd-dclk-freq单位" class="headerlink" title="更改lcd_dclk_freq单位"></a>更改lcd_dclk_freq单位</h2><p>具体需要在内核中更改的两个文件，如果你uboot也开了显示，那uboot的对应位置也需要修改。</p><p><code>drivers/video/fbdev/sunxi/disp2/disp/de/disp_lcd.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c">diff --git a/drivers/video/fbdev/sunxi/disp2/disp/de/disp_lcd.c b/drivers/video/fbdev/sunxi/disp2/disp/de/disp_lcd.c<br>index <span class="hljs-number">22</span>c5636a1..dc9c87fda <span class="hljs-number">100644</span><br>--- a/drivers/video/fbdev/sunxi/disp2/disp/de/disp_lcd.c<br>+++ b/drivers/video/fbdev/sunxi/disp2/disp/de/disp_lcd.c<br>@@ <span class="hljs-number">-652</span>,<span class="hljs-number">15</span> +<span class="hljs-number">652</span>,<span class="hljs-number">19</span> @@ <span class="hljs-type">static</span> s32 <span class="hljs-title function_">lcd_clk_config</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disp_device *lcd)</span><br>        <span class="hljs-title function_">disp_al_lcd_get_clk_info</span><span class="hljs-params">(lcd-&gt;hwdev_index, &amp;clk_info,</span><br><span class="hljs-params">                                 &amp;lcdp-&gt;panel_info)</span>;<br>-       dclk_rate = lcdp-&gt;panel_info.lcd_dclk_freq * <span class="hljs-number">1000000</span>; <br>+    <span class="hljs-comment">// dclk_rate = lcdp-&gt;panel_info.lcd_dclk_freq * 1000000; </span><br>+    dclk_rate = lcdp-&gt;panel_info.lcd_dclk_freq * <span class="hljs-number">1000</span>; <span class="hljs-comment">/* Mhz -&gt; khz */</span><br><br>@@ <span class="hljs-number">-722</span>,<span class="hljs-number">7</span> +<span class="hljs-number">726</span>,<span class="hljs-number">11</span> @@ <span class="hljs-type">static</span> s32 <span class="hljs-title function_">lcd_clk_config</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disp_device *lcd)</span><br>                     pll_rate_set, lcd_rate_set, dclk_rate_set, dsi_rate_set);<br>        &#125;<br><br>+    DE_WRN(<span class="hljs-string">&quot;disp %d, clk: pll(%ld),clk(%ld),dclk(%ld) dsi_rate(%ld)\n     clk real:pll(%ld),clk(%ld),dclk(%ld) dsi_rate(%ld)\n&quot;</span>,<br>+           lcd-&gt;disp, pll_rate, lcd_rate, dclk_rate, dsi_rate,<br>+           pll_rate_set, lcd_rate_set, dclk_rate_set, dsi_rate_set);<br>+<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br><br> <span class="hljs-type">static</span> s32 <span class="hljs-title function_">lcd_clk_enable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disp_device *lcd)</span><br>@@ -834,8 +842,10 @@ <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lcd_calc_judge_line</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disp_device *lcd)</span><br>                 *               = ht / dclk(Mhz)<br>                 */<br>-               lcdp-&gt;usec_per_line = panel_info-&gt;lcd_ht<br>+               lcdp-&gt;usec_per_line = panel_info-&gt;lcd_ht * <span class="hljs-number">1000</span><br>/ panel_info-&gt;lcd_dclk_freq;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (lcdp-&gt;judge_line == <span class="hljs-number">0</span>) &#123;<br>@@ <span class="hljs-number">-1592</span>,<span class="hljs-number">9</span> +<span class="hljs-number">1602</span>,<span class="hljs-number">13</span> @@ <span class="hljs-type">static</span> s32 <span class="hljs-title function_">disp_lcd_cal_fps</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disp_device *lcd)</span><br>        lcdp-&gt;frame_per_sec =<br>+           DIV_ROUND_CLOSEST(panel_info-&gt;lcd_dclk_freq * <span class="hljs-number">1000</span> *<br>                                  (panel_info-&gt;lcd_interlace + <span class="hljs-number">1</span>),<br>                              panel_info-&gt;lcd_ht * panel_info-&gt;lcd_vt);<br>+       <span class="hljs-comment">// lcdp-&gt;frame_per_sec =</span><br>+       <span class="hljs-comment">//     DIV_ROUND_CLOSEST(panel_info-&gt;lcd_dclk_freq * 1000000 *</span><br>+       <span class="hljs-comment">//                        (panel_info-&gt;lcd_interlace + 1),</span><br>+       <span class="hljs-comment">//                    panel_info-&gt;lcd_ht * panel_info-&gt;lcd_vt);</span><br><br>        ret = <span class="hljs-number">0</span>;<br> OUT:<br>@@ <span class="hljs-number">-2669</span>,<span class="hljs-number">7</span> +<span class="hljs-number">2683</span>,<span class="hljs-number">8</span> @@ <span class="hljs-type">static</span> s32 <span class="hljs-title function_">disp_lcd_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> disp_device *lcd)</span><br>                panel_info = &amp;lcdp-&gt;panel_info;<br><br>-               timmings-&gt;pixel_clk = panel_info-&gt;lcd_dclk_freq * <span class="hljs-number">1000</span>;<br>+               <span class="hljs-comment">// timmings-&gt;pixel_clk = panel_info-&gt;lcd_dclk_freq * dclk_scale;</span><br>+               timmings-&gt;pixel_clk = panel_info-&gt;lcd_dclk_freq;<br>                timmings-&gt;x_res = panel_info-&gt;lcd_x;<br>                timmings-&gt;y_res = panel_info-&gt;lcd_y;<br>                timmings-&gt;hor_total_time = panel_info-&gt;lcd_ht;<br></code></pre></td></tr></table></figure><p>另一个是<code>drivers/video/fbdev/sunxi/disp2/disp/de/lowlevel_v33x/tcon/de_lcd.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">diff --git a/drivers/video/fbdev/sunxi/disp2/disp/de/lowlevel_v33x/tcon/de_lcd.c b/drivers/video/fbdev/sunxi/disp2/disp/de/lowlevel_v33x/tcon/de_lcd.c<br>index <span class="hljs-number">8</span>c811a7ba.<span class="hljs-number">.604</span>bc5fc3 <span class="hljs-number">100644</span><br>--- a/drivers/video/fbdev/sunxi/disp2/disp/de/lowlevel_v33x/tcon/de_lcd.c<br>+++ b/drivers/video/fbdev/sunxi/disp2/disp/de/lowlevel_v33x/tcon/de_lcd.c<br>@@ <span class="hljs-number">-663</span>,<span class="hljs-number">9</span> +<span class="hljs-number">663</span>,<span class="hljs-number">10</span> @@ <span class="hljs-type">static</span> s32 <span class="hljs-title function_">tcon0_cfg_mode_tri</span><span class="hljs-params">(u32 sel, <span class="hljs-keyword">struct</span> disp_panel_para *panel)</span><br> &#123;<br>        u32 start_delay = <span class="hljs-number">0</span>;<br>-       u32 de_clk_rate = de_get_clk_rate() / <span class="hljs-number">1000000</span>;<br>+       <span class="hljs-comment">// u32 de_clk_rate = de_get_clk_rate() / 1000000;</span><br>+       u32 de_clk_rate = de_get_clk_rate() / <span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure><p>这样就可以更改单位为kHz</p><p>可以看到我在<code>lcd_clk_config</code>函数的末尾增加了一个打印，这个打印原来只会在设置的dclk与实际dclk不符合的时候才会打印，为了方便调试，我在正常情况也添加了这个打印。</p><p>然后将<code>lcd_dclk_freq</code> 的数值改为 74250 或者 37125，按道理就可以输出了我们需要的时钟了，然而并没有。配置成74250后的打印如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">disp <span class="hljs-number">1</span>, clk: pll(<span class="hljs-number">519750000</span>),clk(<span class="hljs-number">519750000</span>),dclk(<span class="hljs-number">74250000</span>) dsi_rate(<span class="hljs-number">519750000</span>)<br>     clk real:pll(<span class="hljs-number">519000000</span>),clk(<span class="hljs-number">519000000</span>),dclk(<span class="hljs-number">74142857</span>) dsi_rate(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>可以看到实际选择的pll时钟并不对。</p><h2 id="分频系数"><a href="#分频系数" class="headerlink" title="分频系数"></a>分频系数</h2><p>这个pll的值可以在<code>drivers/clk/sunxi/clk-sun50iw9_tbl.c</code>中的factor_pllvideo1_tbl中找到，具体用的是哪个结构体得看在对应的clk.dtsi中这个设备挂的是哪个时钟树，比如我当前配置的是lcd1，在<code>sun50iw9p1-clk.dtsi</code>中可以看到是video1的pll时钟。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">clk_tcon_lcd1: tcon_lcd1 &#123;<br><span class="hljs-meta">#clock-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br>compatible = <span class="hljs-string">&quot;allwinner,periph-clock&quot;</span>;<br>clock-output-names = <span class="hljs-string">&quot;tcon_lcd1&quot;</span>;<br>assigned-clock-parents = &lt;&amp;clk_pll_video1&gt;;<br>assigned-clocks = &lt;&amp;clk_tcon_lcd1&gt;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>查看该表格，可以找到有很多离散的频率值，那么这个dclk是怎么通过pll算来的呢？</p><p>可以看到打印信息中，dclk和pll差了7倍，这个分频系数，在<code>kernel/linux-4.9/drivers/video/fbdev/sunxi/disp2/disp/de/lowlevel_v33x/disp_al_tcon.c</code>中可以看到，LVDS的分频系数就是7</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lcd_clk_info</span> <span class="hljs-title">clk_tbl</span>[] =</span> &#123;<br>&#123;LCD_IF_HV, <span class="hljs-number">16</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>&#123;LCD_IF_CPU, <span class="hljs-number">12</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>&#123;LCD_IF_LVDS, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>       <span class="hljs-comment">/* ... */</span><br></code></pre></td></tr></table></figure><p>在<code>kernel/linux-4.9/drivers/video/fbdev/sunxi/disp2/disp/de/disp_lcd.c</code>中可以看到函数<code>lcd_clk_config</code>,就是实际设置pll和dclk的地方。而当我们设置74250kHz的时候，函数会在pll的table中找到一个最<strong>接近</strong> 74250000 * 7 的值，然后配置为输出时钟。查表可以看到，在分频系数为7的时候，我们得不到准确的时钟。</p><p>于是我们便想修改LVDS的分频系数。通过简单计算，修改为分频系数为8，也就是设为<code>&#123;LCD_IF_LVDS, 8, 1, 1, 0&#125;</code>。查看打印可以发现软件设置中时钟是准确的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">594000000</span><br>disp <span class="hljs-number">1</span>, clk: pll(<span class="hljs-number">594000000</span>),clk(<span class="hljs-number">594000000</span>),dclk(<span class="hljs-number">74250000</span>) dsi_rate(<span class="hljs-number">594000000</span>)<br>     clk real:pll(<span class="hljs-number">594000000</span>),clk(<span class="hljs-number">594000000</span>),dclk(<span class="hljs-number">74250000</span>) dsi_rate(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>事情到这里还没有结束，我用示波器测量LVDS出来的时钟信号，发现时钟信号失真。而可以测量的部分频率也不对，真实值差不多还是pll &#x2F;7</p><p><img src="https://raw.githubusercontent.com/FreddieGeorge/blogImg/main/img/lvds_div_8.jpg" alt="LVDS 时钟失真"></p><blockquote><p>这个配图是37.125MHz的，74.25MHz的没有拍,可以看到测出来的大概是43Mhz，此时的pll是297000000，297Mhz &#x2F; 7 大概就是42MHz</p></blockquote><p>这个时候我就开始怀疑lvds的时钟分频是否不能修改，但是为了严谨我还是试了很多频率和很多分频系数，发现只要分频系数不为7或者7的倍数，实际的时钟就会失真。而如果是7的倍数，比如14，时钟信号是正常的，但是实际的dclk还是pll &#x2F; 7。于是我就去翻阅T5的用户手册，找到了这样一段描述</p><blockquote><p>If interface is LVDS interface, the frequency of DCLK is one seventh of PLL VIDEO, that is, LCDDclk DIV is 7. (For details, see the timming parameter of LVDS)</p></blockquote><p>再查看了LVDS的时序图，可以看到一个时钟周期会发送7个数据，猜测全志的LVDS时序是PLL时钟用来采样数据，PLL&#x2F;7 直接当作dclk频率，达到同步。而软件的分频设置并没有用，反而会影响正常的采样，导致输出时钟波形失真</p><p><img src="https://raw.githubusercontent.com/FreddieGeorge/blogImg/main/img/LVDS_timming.png" alt="LVDS的时序图"></p><h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p>在分频系数只能为7的情况下，我们只能从时钟那边入手，看下有没有可能找到一个合适的时钟。查看T5的用户手册可以看到PLL时钟的计算公式</p><blockquote><p>PLL_VIDEO0(4X)&#x3D; 24 MHz * N&#x2F;M.<br>PLL_VIDEO0(1X)&#x3D; 24 MHz * N&#x2F;M&#x2F;4.</p></blockquote><p>而这个N M的值可以从文档看到是设置在寄存器的，N的取值范围是1-255，M的范围是1-2。</p><p>再回到我们看到的那个table，拿出一个举例</p><p><code>PLLVIDEO1(84,0,510000000U)</code> ，这个84和0，对应的应该就是这两个值，但是可以看到设在寄存器里的值是需要+1才是对应的N和M，故我们验算 24 * 85 &#x2F; 1 &#x2F; 4 &#x3D; 510MHz，验算正确。</p><p>那我们就需要考虑一下，根据这个两个公式和取值范围，也没有可能达到我们需要的PLL值，也就是74250000 * 7 &#x3D; 519750000 和 37125000 * 7 &#x3D; 259875000。</p><p>最后算了一下是不可能的，所以在无法修改分频系数的情况下，得不到我们想要的一个准确时钟，只能获得一个接近值。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的验证结果就是以全志T507的LVDS时钟设计，是无法满足转换芯片的要求。</p><blockquote><p>之前用BT656出来的是可以更改分频系数的，可以达到准确的速率，可是全志T507的BT656把两个LVDS的引脚都复用了</p></blockquote><p>而LCD屏幕的设计，导致它的dclk可以在允许的范围内变化，在一个差不多的dclk内可以正常显示。但是如果要输出给这款转换芯片，那就达不到要求，只能考虑换芯片等方案。</p><p>这次的验证花了比较长的时间，但是总的来说还是收获了很多，学会了设备树lcd相关的各个参数的意义，全志disp驱动的大致框架，示波器也熟悉了很多。接下来手头还有几个任务，这段时间的更新可能要继续咕咕咕了。 </p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
      <category>全志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>T507</tag>
      
      <tag>LVDS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell脚本笔记</title>
    <link href="/2023/03/02/shell%E8%84%9A%E6%9C%AC%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/02/shell%E8%84%9A%E6%9C%AC%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在工作中编写了几个脚本方便自己的工作流程，在其中也遇到了几个问题，也积累了一些方法和技巧。这篇博客中记录一些shell脚本相关的知识点，但不会包含最基本的内容。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p><a href="https://www.cyberciti.biz/faq/bash-for-loop/">bash-for-loop</a></p><p>for循环的基本语法如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">for varname in list<br>do<br>    # do something<br>done<br></code></pre></td></tr></table></figure><p>for循环的主要用途是将list的元素取出，依序放到varname中，然后执行do和done之间的命令，直到所有元素被取出。</p><p>for常用来遍历文件，或者遍历整数等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">file loop</span><br>for VARIABLE in file1 file2 file3<br>do<br>    command1 on $VARIABLE<br>    command2<br>    commandN<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">var loop</span><br>for VARIABLE in 1 2 3 4 5 .. N<br>do<br>    command1<br>    command2<br>    commandN<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这种是更高级的使用方法，详细见参考资料</span><br>for OUTPUT in $(Linux-Or-Unix-Command-Here)<br>do<br>    command1 on $OUTPUT<br>    command2 on $OUTPUT<br>    commandN<br>done<br></code></pre></td></tr></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p><a href="https://blog.csdn.net/guodongxiaren/article/details/43341769">玩转Bash脚本：循环结构之while循环</a></p><p>while循环的基本语法如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">while condition<br>do<br>    # do something<br>done<br></code></pre></td></tr></table></figure><p>while循环经常用到的是搭配转向输入，例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>while grep &quot;123&quot;<br>do<br><span class="hljs-meta prompt_">  # </span><span class="language-bash"><span class="hljs-keyword">do</span> somethin</span><br>done &lt; /path/to/file<br></code></pre></td></tr></table></figure><p>这个脚本是用来将文件内容逐行传递给while后面的指令，然后再执行循环体。</p><p>当循环体为空,则可以看成<code>cat /path/to/file | grep &quot;123&quot;</code></p><p>搭配转向的使用更多是结合<code>read</code>，用来将文件内容逐行去除，赋给read后面的变量。</p><p>此外还有一个until循环，就是while循环的相反用法，while测试的是真值，until判断的是假值</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>shell的分支包括两种，<code>if else</code> 和 <code>case in</code>。</p><h3 id="if-esle"><a href="#if-esle" class="headerlink" title="if esle"></a>if esle</h3><p>基本语法如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ command_1 ];then<br>    # do something<br>elif [ command_2 ];then<br>    # do something<br>else<br>    # do something<br>fi<br></code></pre></td></tr></table></figure><p>我比较喜欢这种写在同一行的写法，看上去比较像c的if和else，这种写法有几个注意事项</p><ul><li>if和<code>[]</code>之间要有空格</li><li><code>[</code>的后面和<code>]</code>的前面必须要有空格</li><li>if 和 then如果在同一行需要添加 <code>;</code></li><li><code>]</code> 和 <code>;</code> 之间不能有空格</li></ul><p>接下来是一些比较常用的判断式子，有些我会直接用类似C语言的方式描述他们的作用,参考自<a href="https://www.jb51.net/article/235932.htm">该文章</a></p><h4 id="常用数字判断"><a href="#常用数字判断" class="headerlink" title="常用数字判断"></a>常用数字判断</h4><table><thead><tr><th align="center">表达式</th><th align="center">作用</th><th align="center">指令含义</th></tr></thead><tbody><tr><td align="center">[ int1 -eq int2 ]</td><td align="center">int1 &#x3D;&#x3D; int2</td><td align="center">equal</td></tr><tr><td align="center">[ int1 -ne int2 ]</td><td align="center">int1 !&#x3D; int2</td><td align="center">not equal</td></tr><tr><td align="center">[ int1 -gt int2 ]</td><td align="center">int1 &gt;  int2</td><td align="center">grearter than</td></tr><tr><td align="center">[ int1 -ge int2 ]</td><td align="center">int1 &gt;&#x3D; int2</td><td align="center">greater equal</td></tr><tr><td align="center">[ int1 -lt int2 ]</td><td align="center">int1 &lt;  int2</td><td align="center">less than</td></tr><tr><td align="center">[ int1 -le int2 ]</td><td align="center">int1 &lt;&#x3D; int2</td><td align="center">less equal</td></tr></tbody></table><h4 id="常用字符串判断"><a href="#常用字符串判断" class="headerlink" title="常用字符串判断"></a>常用字符串判断</h4><table><thead><tr><th align="center">表达式</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">[ -z str ]</td><td align="center">如果str为空则返回真</td></tr><tr><td align="center">[ -n str ]</td><td align="center">如果str不为空则返回真</td></tr><tr><td align="center">[ str1 &#x3D;&#x3D; str2 ]</td><td align="center">字符串是否相等</td></tr><tr><td align="center">[ str1 !&#x3D; str2 ]</td><td align="center">字符串是否不相等</td></tr></tbody></table><h4 id="常用文件判断"><a href="#常用文件判断" class="headerlink" title="常用文件判断"></a>常用文件判断</h4><p>文件类型判断</p><blockquote><p>该表格内指令都会先判断文件是否存在，如果不存在直接返回假</p></blockquote><table><thead><tr><th align="center">表达式</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">[ -e FILE ]</td><td align="center">判断文件或者目录是否存在</td></tr><tr><td align="center">[ -b FILE ]</td><td align="center">判断文件是否为块设备文件</td></tr><tr><td align="center">[ -c FILE ]</td><td align="center">判断文件是否为字符设备文件</td></tr><tr><td align="center">[ -d DIR ]</td><td align="center">判断文件是否为目录文件</td></tr><tr><td align="center">[ -f FILE ]</td><td align="center">判断文件是否为普通文件</td></tr><tr><td align="center">[ -L FILE ]</td><td align="center">判断文件是否为符号链接文件</td></tr><tr><td align="center">[ -p FILE ]</td><td align="center">判断文件是否为管道文件</td></tr><tr><td align="center">[ -s FILE ]</td><td align="center">判断文件是否为空</td></tr><tr><td align="center">[ -S FILE ]</td><td align="center">判断文件是否为套接字文件</td></tr></tbody></table><p>文件权限判断</p><blockquote><p>该表格内指令都会先判断文件是否存在，如果不存在直接返回假</p></blockquote><table><thead><tr><th align="center">表达式</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">[ -r FILE ]</td><td align="center">判断文件是否有读权限</td></tr><tr><td align="center">[ -w FILE ]</td><td align="center">判断文件是否有写权限</td></tr><tr><td align="center">[ -x FILE ]</td><td align="center">判断文件是否有执行权限</td></tr></tbody></table><p>文件之间比较</p><table><thead><tr><th align="center">表达式</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">[ FILE1 -nt FILE2 ]</td><td align="center">判断文件1修改时间是否比文件2新</td></tr><tr><td align="center">[ FILE1 -ot FILE2 ]</td><td align="center">判断文件1修改时间是否比文件2旧</td></tr><tr><td align="center">[ FILE1 -ef FILE2 ]</td><td align="center">判断文件1是否与文件2的Inode一致，常用于判断硬链接</td></tr></tbody></table><h4 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h4><table><thead><tr><th align="center">表达式</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">[ cmd1 -a cmd2 ]</td><td align="center">逻辑与</td></tr><tr><td align="center">[ cmd1 -o cmd2 ]</td><td align="center">逻辑或</td></tr><tr><td align="center">[ ! cmd2 ]</td><td align="center">逻辑非</td></tr></tbody></table><h3 id="case-in"><a href="#case-in" class="headerlink" title="case in"></a>case in</h3><p>case in 在判断条件比较简单，分支较多时比较好用</p><p>模板如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">case expression in<br>    pattern1)<br>        # do something<br>        ;;<br>    pattern2|pattern3)<br>        # do something<br>        ;;<br>    *)<br>        # do default<br>        ;; # this &quot;;;&quot; can be omitted<br>esac<br></code></pre></td></tr></table></figure><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p><code>case in</code>的pattern部分支持一些简单的正则表达式，具体见表</p><table><thead><tr><th align="center">格式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">*</td><td align="center">任意字符</td></tr><tr><td align="center">[abc]</td><td align="center">a,b,c中的任意一个字符</td></tr><tr><td align="center">[m-n]</td><td align="center">从m到n的任意一个字符</td></tr><tr><td align="center">|</td><td align="center">相当于逻辑或</td></tr></tbody></table><h2 id="路径处理"><a href="#路径处理" class="headerlink" title="路径处理"></a>路径处理</h2><!-- 待更新 --><p>一个shell脚本需要获取的最关键的路径主要有：shell脚本所在位置的绝对路径，执行脚本的路径。</p><h3 id="脚本所在位置的绝对路径"><a href="#脚本所在位置的绝对路径" class="headerlink" title="脚本所在位置的绝对路径"></a>脚本所在位置的绝对路径</h3><p>shell脚本的路径可以使用dirname来获取，使用也比较简单</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">dirname</span></span><br>SHELL_FOLDER=$(cd $(dirname &quot;$0&quot;);pwd)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">readlink</span></span><br>SHELL_FOLDER=$(dirname $(readlink -f &quot;$0&quot;))<br></code></pre></td></tr></table></figure><h3 id="执行脚本的路径"><a href="#执行脚本的路径" class="headerlink" title="执行脚本的路径"></a>执行脚本的路径</h3><p>执行脚本的路径直接使用<code>pwd</code>即可</p><h2 id="打印帮助信息"><a href="#打印帮助信息" class="headerlink" title="打印帮助信息"></a>打印帮助信息</h2><p>参考自该<a href="https://developer.aliyun.com/article/972038">文章</a>，这文章讲得很详细了。</p><p>我们只需要在开头部分写入三个<code>###</code>起始的注释，利用sed指令即可完成打印，编写一个help函数即可,然后根据后面的参数处理部分使用-h即可打印出来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## Info</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## ......</span></span><br><br>help() &#123;<br>    sed -rn &#x27;s/^### ?//;T;p;&#x27; &quot;$0&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>参数处理要用到的几个特殊字符</p><table><thead><tr><th align="center">字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">$#</td><td align="center">传递到脚本的参数个数</td></tr><tr><td align="center">$*</td><td align="center">以一个单字符显示所有向脚本传递的参数</td></tr><tr><td align="center">$$</td><td align="center">脚本程序运行的当给钱进程ID号</td></tr><tr><td align="center">$!</td><td align="center">后台运行的最后一个进程的ID号</td></tr><tr><td align="center">$@</td><td align="center">显示所有向脚本传递的参数，但是每个参数都加引号</td></tr><tr><td align="center">$0</td><td align="center">脚本文件名称</td></tr><tr><td align="center">$n</td><td align="center">第 n 个参数</td></tr><tr><td align="center">$?</td><td align="center">最后指令的退出状态。0表示没有任何错误</td></tr><tr><td align="center">$-</td><td align="center">shell使用的当前选项</td></tr></tbody></table><p>参数处理最基本的就是使用 $1 $2 等对执行的参数一个个判断，但是这样的问题就是你必须按照顺序给程序输入参数，而且不能对于可变化的参数无法判断。而getopt和getopts可以解决这个问题，getopt是getopts的拓展，这边只讲getopt的使用</p><p>getopt的详细用法</p><p>我的参数处理模板为(程序参考自<a href="https://bummingboy.top/2017/12/19/shell%20-%20%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F(%E6%89%8B%E5%B7%A5,%20getopts,%20getopt)/">该博客</a>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">参数处理部分，使用getopt</span><br>ARGS=`getopt -o ht --long tar,help -n &quot;$0&quot; -- &quot;$@&quot;`<br><br>if [ $? != 0 ]; then<br>    echo &quot;Terminating...&quot;<br>    exit 1<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用变量方便后续控制流程</span><br>OPTION_T=0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">将规范化后的命令行参数分配至位置参数（<span class="hljs-variable">$1</span>,<span class="hljs-variable">$2</span>,...)</span><br>eval set -- &quot;$&#123;ARGS&#125;&quot;<br><br>while true<br>do<br>    case &quot;$1&quot; in<br>        -t|--tar) <br>            OPTION_T=1<br>            shift<br>            ;;<br>        -h|--help) <br>            help<br>            exit<br>            shift<br>            ;;<br>        --)<br>            shift<br>            break<br>            ;;<br>        *)<br>            echo &quot;Internal error!&quot;<br>            exit 1<br>            ;;<br>    esac<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">处理完opt后，剩下的参数都在<span class="hljs-variable">$1</span> <span class="hljs-variable">$2</span>...</span><br></code></pre></td></tr></table></figure><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>这部分其实是echo相关的，利用echo的<code>-e</code> 参数输出有颜色的字符，能输出更多样的脚本打印信息，参考自<a href="https://www.cnblogs.com/lr-ting/archive/2013/02/28/2936792.html">该文章</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">字颜色 30-37</span><br>　　echo -e “\033[30m 黑色字 \033[0m” <br>　　echo -e “\033[31m 红色字 \033[0m” <br>　　echo -e “\033[32m 绿色字 \033[0m” <br>　　echo -e “\033[33m 黄色字 \033[0m” <br>　　echo -e “\033[34m 蓝色字 \033[0m” <br>　　echo -e “\033[35m 紫色字 \033[0m” <br>　　echo -e “\033[36m 天蓝字 \033[0m” <br>　　echo -e “\033[37m 白色字 \033[0m” <br><span class="hljs-meta prompt_"># </span><span class="language-bash">背景色 40-47 [&lt;back-color&gt;;&lt;font-color&gt;m</span><br>　　echo -e “\033[40;37m 黑底白字   \033[0m” <br>　　echo -e “\033[41;37m 红底白字   \033[0m” <br>　　echo -e “\033[42;37m 绿底白字   \033[0m” <br>　　echo -e “\033[43;37m 黄底白字   \033[0m” <br>　　echo -e “\033[44;37m 蓝底白字   \033[0m” <br>　　echo -e “\033[45;37m 紫底白字   \033[0m” <br>　　echo -e “\033[46;37m 天蓝底白字 \033[0m” <br>　　echo -e “\033[47;30m 白底黑字   \033[0m” <br><br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数其实比较简单，只需要按照如下写即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">function func_name() &#123;<br>    # do something<br>    # return value<br>&#125;<br></code></pre></td></tr></table></figure><p>而函数也可以通过<code>$n</code>的方式传递参数。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>shell中字符串有两种表达方法，分别是单引号和双引号,具体区别不再赘述，我一般直接使用双引号字符串。</p><h3 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断"></a>字符串判断</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;var&#125;              <span class="hljs-comment"># 变量var的值, 与$var相同</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;var-DEFAULT&#125;      <span class="hljs-comment"># 如果var没有被声明, 那么就以$DEFAULT作为其值 *</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;var:-DEFAULT&#125;     <span class="hljs-comment"># 如果var没有被声明, 或者其值为空, 那么就以$DEFAULT作为其值 *</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;var=DEFAULT&#125;      <span class="hljs-comment"># 如果var没有被声明, 那么就以$DEFAULT作为其值 *</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;var:=DEFAULT&#125;     <span class="hljs-comment"># 如果var没有被声明, 或者其值为空, 那么就以$DEFAULT作为其值 *</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;var+OTHER&#125;        <span class="hljs-comment"># 如果var声明了, 那么其值就是$OTHER, 否则就为null字符串</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;var:+OTHER&#125;       <span class="hljs-comment"># 如果var被设置了, 那么其值就是$OTHER, 否则就为null字符串</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;var?ERR_MSG&#125;      <span class="hljs-comment"># 如果var没被声明, 那么就打印$ERR_MSG *</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;var:?ERR_MSG&#125;     <span class="hljs-comment"># 如果var没被设置, 那么就打印$ERR_MSG *</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;!varprefix*&#125;      <span class="hljs-comment"># 匹配之前所有以varprefix开头进行声明的变量</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;!varprefix@&#125;      <span class="hljs-comment"># 匹配之前所有以varprefix开头进行声明的变量</span></span><br></code></pre></td></tr></table></figure><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;<span class="hljs-comment">#string&#125;                          # $string的长度</span></span> <br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;string:position&#125;                  <span class="hljs-comment"># 在$string中, 从位置$position开始提取子串</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;string:position:length&#125;           <span class="hljs-comment"># 在$string中, 从位置$position开始提取长度为$length的子串</span></span>     <br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;string<span class="hljs-comment">#substring&#125;                 # 从变量$string的开头, 删除最短匹配$substring的子串</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;string<span class="hljs-comment">##substring&#125;                # 从变量$string的开头, 删除最长匹配$substring的子串</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;string%substring&#125;                 <span class="hljs-comment"># 从变量$string的结尾, 删除最短匹配$substring的子串</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;string%%substring&#125;                <span class="hljs-comment"># 从变量$string的结尾, 删除最长匹配$substring的子串</span></span>   <br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;string/substring/replacement&#125;     <span class="hljs-comment"># 使用$replacement, 来代替第一个匹配的$substring</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;string//substring/replacement&#125;    <span class="hljs-comment"># 使用$replacement, 代替所有匹配的$substring</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;string/<span class="hljs-comment">#substring/replacement&#125;    # 如果$string的前缀匹配$substring, 那么就用$replacement来代替匹配到的$substring</span></span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;string/%substring/replacement&#125;    <span class="hljs-comment"># 如果$string的后缀匹配$substring, 那么就用$replacement来代替匹配到的$substring</span></span><br></code></pre></td></tr></table></figure><p>比较常用的是利用字符串操作，处理掉文件的后缀，前缀等。例如在我的一个ffmpeg批量转换的脚本中，对raw文件批量转为bmp文件，就可以这样写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">for file in ./*.raw<br>do<br>    # 去除开头的./<br>    filename=$&#123;file:2&#125;<br><br>    ffmpeg -vcodec rawvideo -f rawvideo -pix_fmt rgb32 -s 1280x720 -i $&#123;filename&#125; -f image2 -vframes 1 -vcodec bmp output/$&#123;filename/%.raw/.bmp&#125;<br>    # 出错停止<br>    if [ $? -ne 0 ];then<br>        exit<br>    fi<br>done<br></code></pre></td></tr></table></figure><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p>shell脚本其实更是一个方便批量处理的工具，许多信息也可以通过linux的指令来完成。</p><h3 id="sed-指令"><a href="#sed-指令" class="headerlink" title="sed 指令"></a>sed 指令</h3><p><a href="https://wangchujiang.com/linux-command/c/sed.html">sed 指令详解</a></p><p>sed是一个非常强大的字符处理工具，可以搭配正则等使用，功能非常强大，用来自动编写文件，对文件反复操作，编写转换程序等。像本文的打印帮助信息就用到了sed。sed的使用非常广泛，有许多奇妙的用法，我也还没有完全掌握，需要不断学习。在<a href="https://www.runoob.com/linux/linux-comm-sed.html">这个文章</a>中有许多案例可以帮助理解。</p><blockquote><p>想要深入学习sed，正则表达式的知识是必不可少的，之后我也打算写一篇关于正则表达式的博客，这里暂且按下不表。</p></blockquote><p>sed 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">a\ # 在当前行下面插入文本。<br>i\ # 在当前行上面插入文本。<br>c\ # 把选定的行改为新的文本。<br>d # 删除，删除选择的行。<br>D # 删除模板块的第一行。<br>s # 替换指定字符<br>h # 拷贝模板块的内容到内存中的缓冲区。<br>H # 追加模板块的内容到内存中的缓冲区。<br>g # 获得内存缓冲区的内容，并替代当前模板块中的文本。<br>G # 获得内存缓冲区的内容，并追加到当前模板块文本的后面。<br>l # 列表不能打印字符的清单。<br>n # 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。<br>N # 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。<br>p # 打印模板块的行。<br>P # (大写) 打印模板块的第一行。<br>q # 退出Sed。<br>b lable # 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。<br>r file # 从file中读行。<br>t label # if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。<br>T label # 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。<br>w file # 写并追加模板块到file末尾。  <br>W file # 写并追加模板块的第一行到file末尾。  <br>! # 表示后面的命令对所有没有被选定的行发生作用。  <br>= # 打印当前行号码。  <br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-comment"># 把注释扩展到下一个换行符以前。</span></span>  <br></code></pre></td></tr></table></figure><p>sed 替换标记</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">g # 表示行内全面替换。  <br>p # 表示打印行。  <br>w # 表示把行写入一个文件。  <br>x # 表示互换模板块中的文本和缓冲区中的文本。  <br>y # 表示把一个字符翻译为另外的字符（但是不用于正则表达式）<br>\1 # 子串匹配标记<br>&amp; # 已匹配字符串标记<br></code></pre></td></tr></table></figure><p>sed 元字符集</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">^ # 匹配行开始，如：/^sed/匹配所有以sed开头的行。<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-comment"># 匹配行结束，如：/sed$/匹配所有以sed结尾的行。</span></span><br>. # 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。<br>* # 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。<br>[] # 匹配一个指定范围内的字符，如/[sS]ed/匹配sed和Sed。  <br>[^] # 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。<br>\(..\) # 匹配子串，保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。<br>&amp; # 保存搜索字符用来替换其他字符，如s/love/ **&amp;** /，love这成 **love** 。<br>\&lt; # 匹配单词的开始，如:/\&lt;love/匹配包含以love开头的单词的行。<br>\&gt; # 匹配单词的结束，如/love\&gt;/匹配包含以love结尾的单词的行。<br>x\&#123;m\&#125; # 重复字符x，m次，如：/0\&#123;5\&#125;/匹配包含5个0的行。<br>x\&#123;m,\&#125; # 重复字符x，至少m次，如：/0\&#123;5,\&#125;/匹配至少有5个0的行。<br>x\&#123;m,n\&#125; # 重复字符x，至少m次，不多于n次，如：/0\&#123;5,10\&#125;/匹配5~10个0的行。  <br></code></pre></td></tr></table></figure><h3 id="trap-命令"><a href="#trap-命令" class="headerlink" title="trap 命令"></a>trap 命令</h3><p>trap指令是一个非常强大的指令，用来指定接受到信号之后的动作，或者在脚本被中断之后执行清理动作，在嵌入式的rcS中就有用到，使用也相对简单，具体看<a href="https://wangchujiang.com/linux-command/c/trap.html">该博客</a>即可。</p><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p><a href="https://wangchujiang.com/linux-command/c/awk.html">awk</a>是一种文本和数据处理的编程语言，功能强大，可以当作是一个脚本程序，具有极高的灵活性,但是使用也相对复杂。</p><p>接下来举个例子，目的是获取某个交叉编译工具链的所在路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">whereis aarch64-linux-gnu-gcc</span><br>aarch64-linux-gnu-gcc: /home/flork/longan/out/gcc-linaro-7.4.1-2019.02-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-gcc<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"></span><br><span class="language-bash">&gt; whereis aarch64-linux-gnu-gcc | sed <span class="hljs-string">&#x27;s/\/bin\/aarch64-linux-gnu-gcc//g&#x27;</span></span> <br>aarch64-linux-gnu-gcc: /home/flork/longan/out/gcc-linaro-7.4.1-2019.02-x86_64_aarch64-linux-gnu<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"></span><br><span class="language-bash">&gt; whereis aarch64-linux-gnu-gcc | sed <span class="hljs-string">&#x27;s/\/bin\/aarch64-linux-gnu-gcc//g&#x27;</span> | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span></span><br>/home/flork/longan/out/gcc-linaro-7.4.1-2019.02-x86_64_aarch64-linux-gnu<br></code></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>获取操作类型: <code>uanme -s</code></li></ul><p>学习这些指令靠背是不太现实的，最好的方法是自己想办法用他们，或者结合别人的例子把每句脚本一点点拆解开来。我是利用<a href="https://github.com/theniceboy">TheCW</a>的dwm脚本，把<code>awk</code>和<code>sed</code>的几个常用语法熟悉了一遍。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最近的情况</title>
    <link href="/2023/02/27/%E6%9C%80%E8%BF%91%E7%9A%84%E6%83%85%E5%86%B5/"/>
    <url>/2023/02/27/%E6%9C%80%E8%BF%91%E7%9A%84%E6%83%85%E5%86%B5/</url>
    
    <content type="html"><![CDATA[<p>这段时间的工作内容还是挺充实的，上上周四，也就是2月16号，我们去了AMS的深圳展览，但是没什么意思。这周五还有一次展览，他们说比上次的好看多了，有点小期待。</p><p>然后展览回来便在开始忙任务，看了一周的全志T507显示模块文档，很坑爹，在设备树中明明写着一个配置项可以支持两个disp各三个channel，但是实际测试了很多次都是有问题的，自己修改了一些驱动代码还是不行。最后使用了dma的方法，将fb映射到内存中，终于成功。</p><p>然而今天开会的时候讨论说起，谈到cpu的处理速度不够快，会占用资源，要换opengl来实现,一个同事说可以看隔壁部门的代码，很好解决。所以暂时闲下来了。</p><p>最近打算看一下rust，看一下嵌入式安卓，dwm的配置也好久没动，各种事情堆在一起，这段时间闲下来开始慢慢更新吧。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>吐槽</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>alacritty配置过程</title>
    <link href="/2023/02/14/alacritty%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/02/14/alacritty%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="2024-3-6-update"><a href="#2024-3-6-update" class="headerlink" title="2024-3-6 update"></a>2024-3-6 update</h2><p>alacritty从v0.13.0后将配置文件从yaml移动到toml文件中，所以之前的yaml文件后续可能会作废，目前官方关于新的toml文件的使用方法还是比较齐全的，可以自行查看<a href="https://alacritty.org/config-alacritty.html">官方手册</a>更新自己的配置文件，后续我的配置文件迁移过来后也会贴一份到博客中(TODO)</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这几天在跟着视频配置自己的dwm的时候了解到了alacritty，号称是最快的终端模拟器，利用GPU加速使得终端反应速度非常快，而且整体也很简约好看，便打算给自己的Manjaro配置一下。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Manjaro安装alacritty也很简单，只需要<code>sudo pacman -S alacritty</code>即可。然后在终端输入<code>alacritty</code>就可以打开了。</p><p>在我安装的时候，alacritty的版本为0.11.0,以下配置都以这个版本为准，如有更新需自行查阅官方文档</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>我也懒得去折腾自己的主题了，感觉<a href="https://github.com/alacritty/alacritty-theme">官方的主题</a>都看着挺顺眼,便安装了官方的主题，直接输入这两条指令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p ~/.config/alacritty/themes<br>git clone https://github.com/alacritty/alacritty-theme ~/.config/alacritty/themes<br></code></pre></td></tr></table></figure><p>然后在开头import自己想要的主题yaml文件，我这边选择的是<code>material_theme</code>主题，具体效果在github的README中都有展示。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在我的Manjaro系统中，alacritty的字体间隔会出现问题，按照<a href="https://www.cnblogs.com/siyingcheng/p/11706436.html">这篇博客</a>的配置文件新建了<code>~/.config/alacritty/alacritty.yml</code>文件，在文件中配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 导入主题颜色配置</span><br><span class="hljs-attr">import:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">/home/flork/.config/alacritty/themes/themes/material_theme.yaml</span><br><span class="hljs-comment"># 原来tabspaces是8</span><br><span class="hljs-attr">tabspaces:</span> <span class="hljs-number">4</span><br><span class="hljs-comment"># 字体使用Soure Code Pro</span><br><span class="hljs-attr">family:</span> <span class="hljs-string">&quot;SauceCodePro&quot;</span><br><span class="hljs-comment"># 背景不透明度</span><br><span class="hljs-attr">background_opacity:</span> <span class="hljs-number">0.9</span><br></code></pre></td></tr></table></figure><p>配置之后依旧没有变化，只有透明度发生了改变，后来才发现这个font的family字段名称要求很严格，必须要跟字体名字一模一样，可以查看<code>fc-list</code>获取字体名字，而且网络上的很多博客和教程都是之前的版本，比如比较多的是0.7.0的版本，很多配置已经不再支持或者变化了，于是我便找到了<a href="https://github.com/alacritty/alacritty/blob/master/alacritty.yml">官方的配置文件</a>,在这里可以看到所有的配置，仔细阅读之后配置如下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 导入主题颜色配置</span><br><span class="hljs-comment"># 导入主题颜色配置</span><br><span class="hljs-attr">import:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">/home/flork/.config/alacritty/themes/themes/material_theme.yaml</span><br><br><span class="hljs-comment"># 设置字体</span><br><span class="hljs-attr">font:</span><br>    <span class="hljs-attr">normal:</span><br>        <span class="hljs-attr">family:</span> <span class="hljs-string">&quot;SauceCodePro Nerd Font Mono&quot;</span><br>        <span class="hljs-attr">style:</span> <span class="hljs-string">Regular</span><br>    <span class="hljs-attr">bold:</span> <br>        <span class="hljs-attr">family:</span> <span class="hljs-string">&quot;SauceCodePro Nerd Font Mono&quot;</span><br>        <span class="hljs-attr">style:</span> <span class="hljs-string">Bold</span><br>    <span class="hljs-attr">italic:</span><br>        <span class="hljs-attr">family:</span> <span class="hljs-string">&quot;SauceCodePro Nerd Font Mono&quot;</span><br>        <span class="hljs-attr">style:</span> <span class="hljs-string">Italic</span><br><br><span class="hljs-comment"># 设置透明度</span><br><span class="hljs-attr">window:</span><br>    <span class="hljs-attr">opacity:</span> <span class="hljs-number">0.8</span><br><br><span class="hljs-comment"># set startup mode</span><br><span class="hljs-attr">startup_mode:</span> <span class="hljs-string">Fullscreen</span><br><br><span class="hljs-comment"># highlight window damage info</span><br><span class="hljs-attr">highlight_damage:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># set cursor style</span><br><span class="hljs-attr">cursor:</span><br>  <span class="hljs-attr">style:</span> <span class="hljs-string">Beam</span><br><br><span class="hljs-comment"># set shotcut</span><br><span class="hljs-attr">key_bindings:</span><br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">Return</span>,   <span class="hljs-attr">mods:</span> <span class="hljs-string">Alt</span>,           <span class="hljs-attr">action:</span> <span class="hljs-string">ToggleFullscreen</span> &#125; <span class="hljs-comment"># bind Alt + Return Fullscreen </span><br>  <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">key:</span> <span class="hljs-string">F11</span>   ,                        <span class="hljs-attr">action:</span> <span class="hljs-string">ToggleFullscreen</span> &#125; <span class="hljs-comment"># bind F11 to Fullscreen </span><br></code></pre></td></tr></table></figure><p>配置之后再次启动alacritty即可</p><p>至此基本配置完成，alacritty也支持设置快捷键，但是目前还没有这些需求，现在就先弄个基础配置。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Manjaro</category>
      
    </categories>
    
    
    <tags>
      
      <tag>alacritty</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的vim配置</title>
    <link href="/2023/02/14/%E6%88%91%E7%9A%84vim%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/02/14/%E6%88%91%E7%9A%84vim%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我很多时间都是在使用vscode，vim也只会一些基础的操作，但是这段时间看了几个博主的vim界面，觉得vim也有它很强大好看的地方，便决定给自己的vim简单配置一下。</p><p>本文基本上都是按照官方文档在配置，也参考了很多博客。</p><blockquote><p>这篇没啥技术含量，基本就是看一下官方的README对着改，然后也没有自己额外配置，属于很基础简单的配置</p></blockquote><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>Ubuntu18.04(经试验Manjaro同样适用)</p><p>vim 9.0</p><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>先按照我的个人喜好将vim的原生配置设置一下。网上也有很多相关的教程配置。我的vim配置已经放到了我的<a href="https://github.com/FreddieGeorge/my_vim.git">github仓库</a></p><p>官方的配置文档可以在vim命令模式输入<code>:h option-list</code>查看完整的选项列表。</p><p>在我的<code>~/.vimrc</code>中,最开始的配置如下，主要作用和功能都有写注释</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs text">set showcmd         &quot; 显示指令<br>set showmode        &quot; 显示当前模式<br><br>set encoding=utf-8  &quot; 设置编码格式<br><br>set laststatus=2    &quot; 状态栏<br>set number          &quot; 显示行号<br>set showmatch       &quot; 显示括号匹配<br>set hlsearch        &quot; 高亮搜索结果<br>set ruler           &quot; 显示光标当前位置<br><br>set tabstop=4       &quot; tab长度<br>set autoindent      &quot; 继承前一行的缩进方式<br>set shiftwidth=4    &quot; 设置自动缩进长度<br>set expandtab       &quot; 空格替换tab<br>set softtabstop=4   &quot; 退格键一次删除4个空格<br><br><br>&quot; 启用鼠标<br>set mouse=a<br>set selection=exclusive<br>set selectmode=mouse,key<br><br>&quot; 设置上下滚动保留行数为5<br>set scrolloff=5<br>&quot; 禁止创建交换文件<br>set noswapfile<br><br>&quot; 设置自动切换目录<br>set autochdir<br><br>&quot; true color<br>set termguicolors<br><br></code></pre></td></tr></table></figure><h2 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h2><p>插件管理我使用的是<a href="https://github.com/VundleVim/Vundle.vim">Vundle</a>,从仓库的README中也可以看到它的安装方法，具体为：</p><ol><li>输入<code>mkdir ~/.vim/bundle</code></li><li><code>git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim</code></li><li>编辑<code>~/.vimrc</code>,在上面的配置后添加如下语句 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs text">set nocompatible              &quot; be iMproved, required<br>filetype off                  &quot; required<br><br>&quot; set the runtime path to include Vundle and initialize<br>set rtp+=~/.vim/bundle/Vundle.vim<br>call vundle#begin()<br>&quot; alternatively, pass a path where Vundle should install plugins<br>&quot;call vundle#begin(&#x27;~/some/path/here&#x27;)<br><br>&quot; let Vundle manage Vundle, required<br>Plugin &#x27;VundleVim/Vundle.vim&#x27;<br><br>&quot; ==========================<br>&quot; Plugin Place<br>&quot; ==========================<br><br>&quot; All of your Plugins must be added before the following line<br>call vundle#end()            &quot; required<br>filetype plugin indent on    &quot; required<br></code></pre></td></tr></table></figure></li><li>之后需要安装的插件只需要放在<code>vundle#begin()</code>和<code>vundle#end()</code>之间即可</li></ol><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><h3 id="主题插件"><a href="#主题插件" class="headerlink" title="主题插件"></a>主题插件</h3><p>主题插件使用的是很经典的<a href="https://github.com/altercation/vim-colors-solarized">vim-colors-solarized</a>,只需要在<code>vundle#begin()</code>和<code>vundle#end()</code>之间加入<code>Plugin &#39;altercation/vim-colors-solarized&#39;</code>，然后在vim中输入<code>:PluginInstall</code>即可自动下载。</p><p>在<code>~/.vimrc</code>中添加配置如下</p><blockquote><p>建议注释好，做好分类</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">let g:solarized_termtrans = 1 &quot; use terminal background<br>let g:solarized_visibility = &quot;high&quot;<br><br>&quot; gui下为light，其他是dark<br>if has(&#x27;gui_running&#x27;)<br>    set background=light<br>else<br>    set background=dark<br>endif<br><br>&quot; 主题设置为solarized<br>colorscheme solarized<br><br></code></pre></td></tr></table></figure><h3 id="目录插件"><a href="#目录插件" class="headerlink" title="目录插件"></a>目录插件</h3><p>目录插件使用的是<a href="https://github.com/preservim/nerdtree">NERDTree</a>,安装方法在官方README中都很详细了</p><p><code>~/.vimrc</code>中</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">call vundle#begin()<br><br>  &quot; ... ...<br>  Plugin &#x27;preservim/nerdtree&#x27;<br><br>call vundle#end()<br></code></pre></td></tr></table></figure><p>neadtree配置上我是安装README配置的，具体如下，更多详细使用方法这里不展开，自行查看文档或者资料</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">&quot; Start NERDTree and put the cursor back in the other window.<br>&quot; vim 打开时自动打开nerdtree但是不聚焦在nerd中<br>autocmd VimEnter * NERDTree | wincmd p<br><br>&quot;  Exit Vim if NERDTree is the only window remaining in the only tab.<br>&quot; 退出vim时如果只剩下nerdtree窗口，nerdtree也退出<br>autocmd BufEnter * if tabpagenr(&#x27;$&#x27;) == 1 &amp;&amp; winnr(&#x27;$&#x27;) == 1 &amp;&amp; exists(&#x27;b:NERDTree&#x27;) &amp;&amp; b:NERDTree.isTabTree() | quit | endif<br><br>&quot; If another buffer tries to replace NERDTree, put it in the other window, and bring back NERDTree.<br>&quot; 防止nerdtree被替代，新窗口自动在nerd之外的窗口打开<br>autocmd BufEnter * if bufname(&#x27;#&#x27;) =~ &#x27;NERD_tree_\d\+&#x27; &amp;&amp; bufname(&#x27;%&#x27;) !~ &#x27;NERD_tree_\d\+&#x27; &amp;&amp; winnr(&#x27;$&#x27;) &gt; 1 |<br>    \ let buf=bufnr() | buffer# | execute &quot;normal! \&lt;C-W&gt;w&quot; | execute &#x27;buffer&#x27;.buf | endif<br><br>&quot; F2 打开NERDTree<br>map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;<br>let NERDTreeWinSize=30<br>&quot; 靠左显示<br>let NERDTreeWinPos=&quot;left&quot;<br></code></pre></td></tr></table></figure><h3 id="状态栏插件"><a href="#状态栏插件" class="headerlink" title="状态栏插件"></a>状态栏插件</h3><p>使用<a href="https://github.com/vim-airline/vim-airline">vim-airline</a>,配置如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text"><br>&quot; ~/.vimrc<br><br>call vundle#begin()<br><br>  &quot; ... ...<br>  Plugin &#x27;vim-airline/vim-airline&#x27;<br>  Plugin &#x27;vim-airline/vim-airline-themes&#x27;<br><br>call vundle#end()<br><br>&quot; ... ...<br><br>&quot; ============= vim-airline ============<br>&quot; 字体<br>let g:airline_powerline_fonts=1<br>&quot; 主题<br>let g:airline_theme=&#x27;minimalist&#x27;<br></code></pre></td></tr></table></figure><h3 id="代码补全插件"><a href="#代码补全插件" class="headerlink" title="代码补全插件"></a>代码补全插件</h3><p>详见<a href="https://freddiegeorge.github.io/2023/02/09/ubuntu18-04%E9%85%8D%E7%BD%AEvim%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8%E6%8F%92%E4%BB%B6YouCompleteMe/">ubuntu18.04配置vim代码补全插件YouCompleteMeu</a></p><h3 id="tagbar插件"><a href="#tagbar插件" class="headerlink" title="tagbar插件"></a>tagbar插件</h3><p>使用<a href="https://github.com/preservim/tagbar">tagbar</a>,配置如下</p><blockquote><p>这个暂时没有用上，不知道具体好不好用，应该是跟vscode的大纲类似的东西</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text"><br>&quot; ~/.vimrc<br><br>call vundle#begin()<br><br>  &quot; ... ...<br>  Plugin &#x27;majutsushi/tagbar&#x27;<br><br>call vundle#end()<br><br>&quot; ... ...<br><br>&quot; ============= tagbar ============<br>let g:tagbar_width=35<br>let g:tagbar_autofocus=1<br>let g:tagbar_left=1 &quot; tagbar放在窗口左边<br>&quot; tagbar启动绑定到F3<br>nmap &lt;F3&gt; :TagbarToggle&lt;CR&gt;  <br></code></pre></td></tr></table></figure><h3 id="goyo插件"><a href="#goyo插件" class="headerlink" title="goyo插件"></a>goyo插件</h3><p><a href="https://news.itsfoss.com/configuring-vim-writing/">goyo</a>还是我在<a href="https://news.itsfoss.com/configuring-vim-writing/">这篇文章</a>看到的，觉得挺有意思，也加上去了。goyo主要还是给写作这种用途使用的，用来专注写作，比如写博客，写小说搭配同一个作者的<a href="https://github.com/junegunn/limelight.vim">limelight</a>效果很不错。但是我这里并没有安装limelight，主要是在ubuntu下面的goyo模式上下会有黑边，在看了issue之后也还没找到解决方法，所以暂时先不管，晚上试试manjaro下效果会不会好一点。</p><p>安装和使用也很简单，在官方的README中就有</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">&quot; ~/.vimrc<br><br>call vundle#begin()<br><br>  &quot; ... ...<br>  Plugin &#x27;junegunn/goyo.vim&#x27;<br><br>call vundle#end()<br><br></code></pre></td></tr></table></figure><h3 id="注释插件"><a href="#注释插件" class="headerlink" title="注释插件"></a>注释插件</h3><p>注释插件使用<a href="https://github.com/preservim/nerdtree">NERDTree</a></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs text">&quot; ~/.vimrc<br><br>call vundle#begin()<br><br>  &quot; ... ...<br>  Plugin &#x27;preservim/nerdcommenter&#x27;<br><br>call vundle#end()<br><br>&quot; ... ...<br>&quot;============ NERDCommenter ======<br>&quot; Create default mappings<br>let g:NERDCreateDefaultMappings = 1<br><br>&quot; Add spaces after comment delimiters by default<br>let g:NERDSpaceDelims = 1<br><br>&quot; Use compact syntax for prettified multi-line comments<br>let g:NERDCompactSexyComs = 1<br><br>&quot; Align line-wise comment delimiters flush left instead of following code indentation<br>let g:NERDDefaultAlign = &#x27;left&#x27;<br><br>&quot; Set a language to use its alternate delimiters by default<br>let g:NERDAltDelims_java = 1<br><br>&quot; Add your own custom formats or override the defaults<br>let g:NERDCustomDelimiters = &#123; &#x27;c&#x27;: &#123; &#x27;left&#x27;: &#x27;/**&#x27;,&#x27;right&#x27;: &#x27;*/&#x27; &#125; &#125;<br><br>&quot; Allow commenting and inverting empty lines (useful when commenting a region)<br>let g:NERDCommentEmptyLines = 1<br><br>&quot; Enable trimming of trailing whitespace when uncommenting<br>let g:NERDTrimTrailingWhitespace = 1<br><br>&quot; Enable NERDCommenterToggle to check all selected lines is commented or not<br>let g:NERDToggleCheckAllLines = 1<br><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后的配置成果还是挺不错的，但是我对vim还是不够熟悉，仅限于一些基本的增删改查操作，目前也没有这个应用习惯，写项目还是使用vscode居多，接下来在我的Manjaro中尽量多尝试一下vim的操作，熟悉一下吧。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu18.04配置vim代码补全插件YouCompleteMe</title>
    <link href="/2023/02/09/ubuntu18-04%E9%85%8D%E7%BD%AEvim%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8%E6%8F%92%E4%BB%B6YouCompleteMe/"/>
    <url>/2023/02/09/ubuntu18-04%E9%85%8D%E7%BD%AEvim%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8%E6%8F%92%E4%BB%B6YouCompleteMe/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这几天都在忙碌公司的项目，没空更新其他博客，但是也在忙中偷闲把工作虚拟机的vim界面给配置了一下，安装了nerdtree等好用的插件，用起来舒服多了。</p><p>然后也了解到了强大的代码补全插件 YouCompleteMe 插件，便想着配置一下。结果这玩意弄了一两天。今天也在这里开个博客记录一下。</p><blockquote><p>这里一开始是用的–all想要一步到位，但是后面出现了golang的bug，我又用不上go，所以后面换–clang-completer<br>所以有些bug不一定能复现出来</p></blockquote><h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><p>虚拟机：VMWare 16.1.1</p><p>ubuntu18.04</p><p>vim 9.0</p><p>vim 插件管理工具 ：vundle</p><h2 id="拉取源码"><a href="#拉取源码" class="headerlink" title="拉取源码"></a>拉取源码</h2><blockquote><p>首先如果有代理的话最好使用代理，不然拉下源码等过程非常漫长，我主机用的clash，在clash里面打开Allow lan就可以在虚拟机配置代理了</p></blockquote><p>Vundle有多种<a href="https://github.com/VundleVim/Vundle.vim#quick-start">拉取源码的方式</a>,直接在vundle#begin() 和vundle#end() 之间加入一句 <code>Plugin &#39;Valloric/YouCompleteMe&#39;</code>,然后在vim中敲入 <code>:PluginInstall</code> 即可自动下载插件。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>YouCompleteMe(以下简称YCM)需要python编译，在git 拉下YCM的源码之后还需要输入 <code>git submodule update --init --recursive</code>添加子模块 <strong>ycmd</strong>。</p><p>在添加完成之后输入 <code>python3 ./install.py --clang-completer</code> 直接失败,提示 <code>ycmd requires Python &gt;= 3.8.0</code>,而ubuntu18.04的默认python版本是python3.6.9。那好吧，我们来配置一下python3.8的环境</p><h3 id="python3-8问题"><a href="#python3-8问题" class="headerlink" title="python3.8问题"></a>python3.8问题</h3><p>首先，我强烈建议ubuntu18.04中的python3的默认版本不要随便修改，否则可能会有很多问题。</p><p>按照<a href="https://www.jianshu.com/p/55a2a009fc1e">这个博客</a>很快就配置好了3.8的环境，这里我并没有直接修改软链接为python，而是选择直接绝对路径调用python3.8。</p><p>配置好之后再次来到YCM的路径，输入<code>/usr/local/python3/bin/python3.8 ./install.py --clang-completer</code>，然后再次报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">found static Python library (/usr/local/python3/lib/libpython3.8.a) but a dynamic one is required. You must use a Python compiled with the --enable-shared flag. If using pyenv, you need to run the command:<br>  export PYTHON_CONFIGURE_OPTS=&quot;--enable-shared&quot;<br></code></pre></td></tr></table></figure><p>好嘛，意思就是我编译出来的python3.8是静态库<code>.a</code>,而YCM需要动态库<code>.so</code>，那我只能再回到python3.8的源码目录，在.&#x2F;configure 后面加了一串 <code>--enable-shared</code>.终于编译出来了动态库<code>libpython3.8.so.1.0</code>,并且把这个文件复制到了 &#x2F;usr&#x2F;lib下面。</p><p>再再再回到YCM的目录，执行<code>/usr/local/python3/bin/python3.8 ./install.py --clang-completer</code>，还在报错。好在这次不是python的问题，这次是g++的问题。</p><h3 id="g-问题"><a href="#g-问题" class="headerlink" title="g++问题"></a>g++问题</h3><p>报错信息为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">CMake Error at CMakeLists.txt:232 (message):<br>  Your C++ compiler does NOT fully support C++17.<br></code></pre></td></tr></table></figure><p>那应该就说g++的版本有问题，再次按照<a href="https://stackoverflow.com/questions/65284572/your-c-compiler-does-not-fully-support-c17">这个回答</a>输入以下指令更改了g++版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install g++-8<br>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 700 --slave /usr/bin/g++ g++ /usr/bin/g++-7<br>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 800 --slave /usr/bin/g++ g++ /usr/bin/g++-8<br></code></pre></td></tr></table></figure><p>继续编译，g++问题解决</p><h3 id="Clang-问题"><a href="#Clang-问题" class="headerlink" title="Clang 问题"></a>Clang 问题</h3><p>还没完，还有报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">CMake Error at ycm/CMakeLists.txt:115 (file):<br>  file DOWNLOAD HASH mismatch<br></code></pre></td></tr></table></figure><p>累了，直接找到github的issue找到<a href="https://github.com/ycm-core/YouCompleteMe/issues/1711#issuecomment-145131863">这个问题</a>,按照这个回答，我们把<a href="http://llvm.org/releases/3.7.0/clang+llvm-3.7.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz">他提供的下载链接</a>对应的文件下载下来，然后放入<code>~/.vim/bundle/YouCompleteMe/third_party/ycmd/clang_archives</code>中，不需要解压，然后重新执行 install.py,发现还是在下载，仔细一看这个回答都已经是2015年的回答了。于是继续找原因。</p><blockquote><p>奇怪的是，错误之后我就下班了，今天上班重新执行了install，一样的指令，这次就通过了，想不明白为什么。。。</p></blockquote><p>&lt;<br>我又不用golang，</p><h3 id="golang环境问题"><a href="#golang环境问题" class="headerlink" title="golang环境问题"></a>golang环境问题</h3><p>继续报错。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">can&#x27;t load package: package golang.org/x/tools/gopls@v0.9.4<br>//....<br>package golang.org/x/tools/gopls@v0.9.4: unrecognized import path &quot;golang.org/x/tools/gopls@v0.9.4&quot; <br></code></pre></td></tr></table></figure><p>应该是golang的环境没有配，看来一下应该是缺少gopls，尝试手动下载，在终端输入<code>go get golang.org/x/tools/gopls</code>,等待一段时间后报错<code>dial tcp 142.251.42.241:443: i/o timeout</code>，那大概知道什么问题了。再次尝试ping这个ip，果然连接不上。奇怪的是我明明有配置代理，在主机端（也就是win下）ping这个ip，还是失败。</p><p>然后我选择直接直接–all换–clang-completer，直接通过编译，然后打开vim输入:PluginInstall  即可</p><p>至此安装完成</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>vim</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro从KDE更换为dwm</title>
    <link href="/2023/01/31/Manjaro%E4%BB%8EKDE%E6%9B%B4%E6%8D%A2%E4%B8%BADWM/"/>
    <url>/2023/01/31/Manjaro%E4%BB%8EKDE%E6%9B%B4%E6%8D%A2%E4%B8%BADWM/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看到一个<a href="https://www.zhihu.com/question/399967127/answer/1805622525">知乎答主的dwm桌面配置</a>，感觉很有趣，便决定对自己kde桌面的manjaro笔记本改造一番。而且KDE桌面有几个问题让我有点难以接受，首先是加载时间太长了，我的笔记本在登录用户之后还需要读条一段时间才能进入桌面，而且现在对于我来说桌面环境也没怎么用上过了，开机第一件事情就是打开终端。所以就</p><p>这篇博客主要是自己折腾的记录，结合了很多博客，更多的还是查阅arch的wiki，如果想要自己学的话，多看官方文档和wiki等资料。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>首先还是推荐仔细查看官方文档，文档对dwm的文件作用等写得很详细</p><p><a href="https://dwm.suckless.org/">dwm官方文档</a></p><p><a href="https://wiki.archlinux.org/title/dwm">Arch Linux dwm 文档</a></p><p><a href="https://zhuanlan.zhihu.com/p/395307199">Manjaro&#x2F;Arch Linux 下基于dwm打造完美桌面环境 (二): 安装基础组件 - 彭亚伦</a></p><blockquote><p>(这篇后续咕咕咕了，但是还是很感谢大佬)</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/183861786">入坑dwm——原来窗口管理器还可以这样用 - 阿州</a></p><p><a href="https://www.youtube.com/watch?v=dP8OKP-r1tw">Simple DWM install on Manjaro XFCE&#x2F;KDE - YouTube</a>(我大体上是根据这个视频来操作的，但是需要魔法)</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>我现在的桌面用的KDE，如果有用过unbuntu的话应该也听过GNOuME，而GNOME，KDE等都是叫做桌面环境 *(Desktop Enviroment,DE)*，同时这几个都带了自己的窗口管理器 *(WindowS Manager,WM)*，主要通过鼠标操作；而dwm,i3wm等只有WM，主要通过键盘操作。</p><p>而我们用来登录的界面，叫做显示管理器 <em>(Display Manger,DM)</em>,负责引导用户输入账号密码进入桌面，接下来就交给KDE了。所以我们在从KDE切换到dwm的时候，只需要重启登录的时候选择对应的KDE或者dwm就行了。</p><blockquote><p>如果你折腾过 Arch Linux那你肯定知道配置sddm等显示管理器。</p></blockquote><p>dwm <em>(Dynamic window manager)</em> 是 suckless开发的一个用于 <a href="https://www.x.org/wiki/">X</a> 的动态桌面管理器。从他的英文原名的 <em>Dynamic</em> 也能看出来它的一个特点是动态，在dwm上的布局都可以动态应用。dwm的可定制性非常高，资源占用极低，非常轻量，源码大小只有80多KB。如果有一定的编程和linux基础的话可以尝试一下dwm。</p><blockquote><p>我想要更换KDE的一个原因也是KDE的占用有点高，而且会卡顿</p></blockquote><h2 id="环境介绍"><a href="#环境介绍" class="headerlink" title="环境介绍"></a>环境介绍</h2><ul><li>cpu: i5-8250U</li><li>操作系统：Manjaro with Plasma(X11)</li></ul><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h3 id="安装dwm"><a href="#安装dwm" class="headerlink" title="安装dwm"></a>安装dwm</h3><ol><li><code>sudo pacman -S yay git vim base-devel</code></li><li><code>git clone https://git.suckless.org/dwm --depth=1</code></li><li><code>cd dwm</code></li><li><code>sudo make clean install</code></li></ol><h3 id="安装st"><a href="#安装st" class="headerlink" title="安装st"></a>安装st</h3><p>st是一个在X上的简单终端实现</p><ol><li><code>git clone https://git.suckless.org/st --depth=1</code></li><li><code>cd st</code></li><li><code>sudo make clean install</code></li></ol><h3 id="安装dmenu"><a href="#安装dmenu" class="headerlink" title="安装dmenu"></a>安装dmenu</h3><p>dmenu是suckless开发的一个基建的应用程序选择器。安装dmenu只需要终端输入 <code>sudo pacman -S dmenu</code> 即可</p><h3 id="安装Ranger"><a href="#安装Ranger" class="headerlink" title="安装Ranger"></a>安装Ranger</h3><p><code>sudo pacman -S ranger</code></p><h2 id="配置dwm到dm"><a href="#配置dwm到dm" class="headerlink" title="配置dwm到dm"></a>配置dwm到dm</h2><p>安装好之后便可以开始把桌面环境给配置dwm。我们首先需要了解一下系统是怎么知道和选择我们的桌面环境。</p><p>这里就需要回顾刚刚所说的 dm *(display manger)<em>。从<a href="https://wiki.archlinux.org/title/Display_manager#Session_configuration">dm的wiki</a>中可以看到一个关键目录 <code>/usr/share/xsessions/</code>。从wiki中可以知道如果我们需要新增桌面环境的话需要在这个目录下面添加一个</em>.desktop 文件。</p><blockquote><p>To add&#x2F;remove entries to your display manager’s session list, create&#x2F;remove the .desktop files in &#x2F;usr&#x2F;share&#x2F;xsessions&#x2F; as desired.</p></blockquote><p>那我们只需要在这个目录下指定新建一个DWM.desktop文件，指定编译出来的可执行文件就可以了。</p><p>我新建的DWM.desktop 内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Desktop Entry]<br>Encoding=UTF-8<br>Name=DWM<br>Comment=Dynamic Window Manager developed by suckless.org<br>Exec=/usr/local/bin/dwm<br>Icon=<br>Type=Application<br></code></pre></td></tr></table></figure><blockquote><p>Exec 目录可以从dwm源码的Makefile找到</p></blockquote><h2 id="启动DWM"><a href="#启动DWM" class="headerlink" title="启动DWM"></a>启动DWM</h2><p>重启之后就可以在登录界面的右下角看到桌面环境的选择按钮了。</p><blockquote><p>不同dm的桌面环境选择按钮是不一样的，需要仔细寻找一下，如果<code>/usr/share/xsessions/DWM.desktop</code>没有问题的话应该是有DWM的选项的，但是位置不一样。比如Ubuntu18.04的环境按钮选择是需要先选择用户之后才能看到设置的按钮。</p></blockquote><p>选择DWM，登陆账户，就可以看到这个黑乎乎的桌面了。输入 <code>Alt</code> + <code>Shift</code> + <code>Enter</code> 就能看到终端界面了</p><p><img src="https://raw.githubusercontent.com/FreddieGeorge/blogImg/main/img/2023-01-31_20-06.png" alt="DWM桌面初见"></p><blockquote><p>说实话刚看到这个桌面的时候我是想放弃的，真的是太丑陋了xD</p></blockquote><p>至此DWM安装完成，接下来便开始配置我的DWM桌面了</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置方面我参考了b站up主<a href="https://space.bilibili.com/13081489">TheCW</a>的视频和他的github仓库，然后跟着b站<a href="https://www.bilibili.com/video/BV1pr4y1U78u/?share_source=copy_web&vd_source=7f70bc35f201f823b29deb345ca6ea83">9thSummit的视频</a>完成了基本的配置，可以直接看这个视频学习。</p><p>我自己也将<code>config.h</code>做了一些简单的修改，比如更换了<code>*fonts[]</code>和<code>dmenufont[]</code>的字体和字号，由于更换的字体是NerdFont系列的，我再将<code>tags</code>，也就是dwm界面左上角代表不同窗口的1-9更换成了五个图标，还有不同窗口layouts的表示方式也更换为了图标。</p><h3 id="更改终端模拟器"><a href="#更改终端模拟器" class="headerlink" title="更改终端模拟器"></a>更改终端模拟器</h3><p>修改<code>config.h</code>，将<code>Alt</code>+<code>Shift</code>+’Enter<code>的打开的终端改为我想要的</code>alacritty&#96;终端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// static const char *termcmd[] = &#123; &quot;st&quot;, NULL &#125;;</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *termcmd[] = &#123; <span class="hljs-string">&quot;alacritty&quot;</span>, <span class="hljs-literal">NULL</span> &#125;;<br></code></pre></td></tr></table></figure><p>我的具体alacritty配置和安装可以看<a href="https://freddiegeorge.github.io/2023/02/14/alacritty%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/">另一篇博客</a>。</p><p>再次<code>sudo make clean install</code>然后重启就可以看到终端更换了。</p><h3 id="添加patches"><a href="#添加patches" class="headerlink" title="添加patches"></a>添加patches</h3><p>patches在<a href="https://dwm.suckless.org/patches/">suckless的官网中</a>,在左侧能看到有许多patches,如果不想要啃英文一个个找的话，这里有个很优秀的<a href="https://github.com/Katzeee/dwm-patches-chinese">github仓库</a>将patches翻译为中文。</p><p>补丁看自己喜欢的来安装，我个人安装了<code>uselessgap</code>,<code>autostart</code>,<code>barpadding</code>三个补丁，合入的方式为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /your/path/to/dwm_soucre<br><br>patch &lt; /path/to/patches.diff<br></code></pre></td></tr></table></figure><p>补丁在合并的时候可能会与其他补丁产生冲突，要手动对比.rej文件解决冲突。</p><h3 id="添加脚本"><a href="#添加脚本" class="headerlink" title="添加脚本"></a>添加脚本</h3><p>这个脚本是在安装了<code>autostart</code>的基础上使用的。在合入这个脚本之后，可以在<code>dwm.c</code>中看到<code>scan()</code>函数中增加了一句<code>runautostart()</code>和增加了该函数实现。在官网中也可以看到对该脚本的介绍</p><blockquote><p>This patch will make dwm run “<del>&#x2F;.dwm&#x2F;autostart_blocking.sh” and “</del>&#x2F;.dwm&#x2F;autostart.sh &amp;” before entering the handler loop. One or both of these files can be ommited.</p></blockquote><p>脚本这些我暂时还没有研究，等后面再补充自己想要的功能，目前为是照搬了<a href="https://gitee.com/jzz777/dwm">jzz777</a>的脚本，后续我有计划将脚本改造一下，符合我自己的使用习惯。</p><h3 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h3><p>目前只是简单安装了一个picom，暂时还没有研究</p><h3 id="rofi代替dmenu"><a href="#rofi代替dmenu" class="headerlink" title="rofi代替dmenu"></a>rofi代替dmenu</h3><p>dmenu实在太简陋了,我还是喜欢颜值高一点的rofi。直接使用<code>yay -S rofi</code>安装即可，然后将dwm中的<code>config.h</code>修改一下<code>*dmenucmd[]</code>的值.然后简单配置一下rofi的主题即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *dmenucmd[] = &#123; <span class="hljs-string">&quot;rofi&quot;</span>, <span class="hljs-string">&quot;show&quot;</span>, <span class="hljs-string">&quot;drun&quot;</span>, <span class="hljs-string">&quot;-theme&quot;</span>, <span class="hljs-string">&quot;/home/flork/.config/rofi/launchers/tyep-3/style-10.rasi&quot;</span>, <span class="hljs-literal">NULL</span> &#125;;<br></code></pre></td></tr></table></figure><h3 id="壁纸"><a href="#壁纸" class="headerlink" title="壁纸"></a>壁纸</h3><p>壁纸软件使用的是<code>nitrogen</code>，直接用<code>nitrogen /path/to/wallpaper</code>即可设置壁纸，然后在autostart脚本添加<code>nitrogen --restroe &amp;</code>即可</p><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p>最终成果如图所示。</p><p><a href="tbd">!dwm配置图</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一直以来无论是上班还是自己玩，我用linux也很少使用gui，偶尔看到了dwm便大为喜爱，目前除了vim还是不熟悉之外体验和颜值都上升了很多，这篇博客的后半段就是在为配好dwm的manjaro笔记本上使用的，整体还是相当满意的。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Manjaro</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Manjaro</tag>
      
      <tag>dwm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最近的感想以及2023年目标</title>
    <link href="/2023/01/31/%E6%9C%80%E8%BF%91%E7%9A%84%E6%84%9F%E6%83%B3%E4%BB%A5%E5%8F%8A2023%E5%B9%B4%E7%9B%AE%E6%A0%87/"/>
    <url>/2023/01/31/%E6%9C%80%E8%BF%91%E7%9A%84%E6%84%9F%E6%83%B3%E4%BB%A5%E5%8F%8A2023%E5%B9%B4%E7%9B%AE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<p>今天照常上班摸鱼的时候刷到了知乎的一个有关<a href="https://www.zhihu.com/question/399967127/answer/1805622525">你认为哪个Linux发行版更有前途？</a>的一个回答，看到了答主的一个很漂亮的主力机界面，了解到了dwm，进而为了了解dwm发现了一个up主 <a href="https://space.bilibili.com/13081489">TheCW</a>。</p><p>看了他的几个视频发现他从五年级就开始接触C++游戏编程，学习计算机，高中开始学习 Manjaro，自己折腾ranger，学习日语。想想自己初中的时候还只会闷头读书，感到非常惭愧。</p><p>在惭愧之余也让我有了更强烈的求知欲望，我想去学习更多的知识，diy自己的manjaro，做更多自己喜欢做的事情。</p><p>也在这里定下自己这一年的目标:</p><p>工作方面</p><ul><li><input disabled="" type="checkbox"> 通过中级软考</li><li><input disabled="" type="checkbox"> 学习驱动开发</li><li><input disabled="" type="checkbox"> 学习视频处理</li><li><input disabled="" type="checkbox"> 提高自己的c++知识</li></ul><p>个人学习方面</p><ul><li><input disabled="" type="checkbox"> 多看书，多写代码</li><li><input disabled="" type="checkbox"> 继续完善个人博客网站</li><li><input disabled="" type="checkbox"> 学习<a href="https://dwm.suckless.org/">dwm</a></li><li><input disabled="" type="checkbox"> 配置自己的manjaro环境</li><li><input disabled="" type="checkbox"> 学习vim?(尝试一下)</li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Manjaro</tag>
      
      <tag>dwm</tag>
      
      <tag>目标</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从DBus-cxx源码解析官方例程(1)</title>
    <link href="/2023/01/30/%E4%BB%8EDBus-cxx%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E5%AE%98%E6%96%B9%E4%BE%8B%E7%A8%8B/"/>
    <url>/2023/01/30/%E4%BB%8EDBus-cxx%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E5%AE%98%E6%96%B9%E4%BE%8B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="从DBus-cxx源码解析官方例程"><a href="#从DBus-cxx源码解析官方例程" class="headerlink" title="从DBus-cxx源码解析官方例程"></a>从DBus-cxx源码解析官方例程</h1><blockquote><p>Linus Benedict Torvalds 曾说 :“Read The F**king Source Code 🙂!”</p></blockquote><p>该文章仅是个人学习的记录。例程代码来自<a href="https://dbus-cxx.github.io/quick_start_example_0.html">dbus-cxx: Quick start example 0: A simple server and client</a></p><p>首先请先了解 DBus 的基本概念和大致框架再来阅读该文章，并自行从github中拉下一份 DBus-cxx的源码，配合 DBus-cxx 文档和源码注释阅读。文章并不会把所有涉及到的源码都贴出来，有很多省略部分，请自行查找对应源码阅读。源码 Releases 版本为 2.3.0。</p><h2 id="server-cpp"><a href="#server-cpp" class="headerlink" title="server.cpp"></a>server.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dbus-cxx.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">double</span> param1, <span class="hljs-type">double</span> param2)</span> </span>&#123; <span class="hljs-keyword">return</span> param1 + param2; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;DBus::Dispatcher&gt; dispatcher = DBus::StandaloneDispatcher::<span class="hljs-built_in">create</span>();<br><br>    std::shared_ptr&lt;DBus::Connection&gt; conn = dispatcher-&gt;<span class="hljs-built_in">create_connection</span>(DBus::BusType::SESSION);<br><br>    <span class="hljs-keyword">if</span> (conn-&gt;<span class="hljs-built_in">request_name</span>(<span class="hljs-string">&quot;dbuscxx.quickstart_0.server&quot;</span>, DBUSCXX_NAME_FLAG_REPLACE_EXISTING) != DBus::RequestNameResponse::PrimaryOwner)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// create an object on us</span><br>    std::shared_ptr&lt;DBus::Object&gt; object = conn-&gt;<span class="hljs-built_in">create_object</span>(<span class="hljs-string">&quot;/dbuscxx/quickstart_0&quot;</span>, DBus::ThreadForCalling::DispatcherThread);<br><br>    <span class="hljs-comment">// add a method that can be called over the dbus</span><br>    object-&gt;<span class="hljs-built_in">create_method</span>&lt;<span class="hljs-built_in">double</span>(<span class="hljs-type">double</span>, <span class="hljs-type">double</span>)&gt;(<span class="hljs-string">&quot;dbuscxx.Quickstart&quot;</span>, <span class="hljs-string">&quot;add&quot;</span>, sigc::<span class="hljs-built_in">ptr_fun</span>(add));<br><br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="create"><a href="#create" class="headerlink" title="create()"></a>create()</h3><p>首先是第一句：</p><p><code>std::shared_ptrDBus::Dispatcher dispatcher = DBus::StandaloneDispatcher::create();</code></p><p>在<a href="https://dbus-cxx.github.io/classDBus_1_1StandaloneDispatcher.html">官方文档</a>中可以找到 StandaloneDispatcher 这个类的介绍</p><blockquote><p>creates a new thread that handles all of the reading and writing to the bus.</p></blockquote><p><code>StandaloneDispatcher</code> 这个类并不复杂。定位到 create 源码部分，可以看到 <code>create</code> 函数的实现其实是返回了一个<code>StandaloneDispatcher</code> 的类智能指针，且 is_running 的默认参数为 true</p><blockquote><p>后面很多类的创建都是用类似的 create 方法实现，就不再赘述</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;StandaloneDispatcher&gt; <span class="hljs-title">StandaloneDispatcher::create</span><span class="hljs-params">( <span class="hljs-type">bool</span> is_running )</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;StandaloneDispatcher&gt;( <span class="hljs-keyword">new</span> <span class="hljs-built_in">StandaloneDispatcher</span>( is_running ) );<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>StandaloneDispatcher</code> 的构造函数中完成了初始化的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">StandaloneDispatcher::<span class="hljs-built_in">StandaloneDispatcher</span>( <span class="hljs-type">bool</span> is_running ) &#123;<br>    m_priv = std::<span class="hljs-built_in">make_unique</span>&lt;priv_data&gt;();<br><br>    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">socketpair</span>( AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK, <span class="hljs-number">0</span>, m_priv-&gt;process_fd ) &lt; <span class="hljs-number">0</span> ) &#123;<br>        <span class="hljs-built_in">SIMPLELOGGER_ERROR</span>( LOGGER_NAME, <span class="hljs-string">&quot;error creating socket pair&quot;</span> );<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">ErrorDispatcherInitFailed</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( is_running ) &#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">start</span>(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先利用 <code>socketpair</code> 建立一堆匿名的嵌套字连接，使用的是管道流SOCK_STREAM连接，即建立的是双向通道，每一端都可以进行读写，并将套接字描述符分别放在<code>process_fd[0]</code> 和 <code>process_fd[1]</code> 中，然后调用 <code>start()</code> 开始线程.</p><blockquote><p>结合源码不难分析出，DBus-cxx 中 <code>process_fd[0]</code> 是写端，<code>process_fd[1]</code> 是读端</p></blockquote><p>在 <code>start()</code> 中利用 <code>std::thread</code> 开始线程,执行关键的线程函数 <code>dispatch_thread_main</code> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StandaloneDispatcher::dispatch_thread_main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; fds;<br><br>    <span class="hljs-keyword">for</span>( std::shared_ptr&lt;Connection&gt; conn : m_priv-&gt;m_connections ) &#123;<br>        conn-&gt;<span class="hljs-built_in">set_dispatching_thread</span>( std::this_thread::<span class="hljs-built_in">get_id</span>() );<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>( m_priv-&gt;m_running ) &#123;<br>        fds.<span class="hljs-built_in">clear</span>();<br>        fds.<span class="hljs-built_in">push_back</span>( m_priv-&gt;process_fd[ <span class="hljs-number">1</span> ] );<br><br>        <span class="hljs-keyword">for</span>( std::shared_ptr&lt;Connection&gt; conn : m_priv-&gt;m_connections ) &#123;<br>            <span class="hljs-keyword">if</span>( !conn-&gt;<span class="hljs-built_in">is_registered</span>() ) &#123;<br>                conn-&gt;<span class="hljs-built_in">bus_register</span>();<br>            &#125;<br><br>            fds.<span class="hljs-built_in">push_back</span>( conn-&gt;<span class="hljs-built_in">unix_fd</span>() );<br>        &#125;<br><br>  <span class="hljs-comment">// Wait for activity on any of the given FDs.</span><br>  <span class="hljs-comment">// If the system call is interrupted, it will be restarted automatically.</span><br>        std::tuple&lt;<span class="hljs-type">bool</span>, <span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::chrono::milliseconds&gt; fdResponse =<br>            DBus::priv::<span class="hljs-built_in">wait_for_fd_activity</span>( fds, <span class="hljs-number">-1</span> );<br>        std::vector&lt;<span class="hljs-type">int</span>&gt; fdsToRead = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;( fdResponse );<br><br>        <span class="hljs-keyword">if</span>( fdsToRead[ <span class="hljs-number">0</span> ] == m_priv-&gt;process_fd[ <span class="hljs-number">1</span> ] ) &#123;<br>            <span class="hljs-type">char</span> discard;<br>            <span class="hljs-keyword">if</span>( <span class="hljs-built_in">read</span>( m_priv-&gt;process_fd[ <span class="hljs-number">1</span> ], &amp;discard, <span class="hljs-built_in">sizeof</span>( <span class="hljs-type">char</span> ) ) &lt; <span class="hljs-number">0</span> )&#123;<br>                <span class="hljs-built_in">SIMPLELOGGER_DEBUG</span>( LOGGER_NAME, <span class="hljs-string">&quot;Failure reading from dispatch thread process_fd: &quot;</span><br>                                    &lt;&lt; <span class="hljs-built_in">strerror</span>( errno ) );<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">dispatch_connections</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键点有以下几个</p><p>首先在while中能看到一个对 m_connection 的遍历，在执行create的时候 m_connection 中的数量为0，所以并不会进入 bus_register 阶段，这段代码中的 bus_register 就留到下一个语句中来解释。现在只需要知道这个for循环是用来遍历connection 把还没有没有注册的连接向bus中注册，获得 unique name。</p><p>首先看最后的 <code>dispatch_connections()</code>函数，这个函数调用 Connections::dispatch 方法写入和尝试读取bus的信息，并作处理。这样就实现了在线程循环中写入需要些的数据和从bus中读取数据。主要部分如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DispatchStatus <span class="hljs-title">Connection::dispatch</span><span class="hljs-params">( )</span> </span>&#123;<br><span class="hljs-comment">/* ... */</span><br>    <span class="hljs-comment">// Write out any messages we have waiting to be written</span><br>    <span class="hljs-built_in">flush</span>();<br><br>    <span class="hljs-comment">// Try to read a message</span><br>         <span class="hljs-comment">/* ... */</span><br>        std::shared_ptr&lt;Message&gt; incoming = m_priv-&gt;m_transport-&gt;<span class="hljs-built_in">readMessage</span>();<br>        <span class="hljs-comment">/* ... */</span><br><br>    <span class="hljs-comment">// Process any messages that we need to</span><br>    <span class="hljs-built_in">process_single_message</span>();<br><br>    <span class="hljs-keyword">if</span>( m_priv-&gt;m_outgoingMessages.<span class="hljs-built_in">empty</span>() &amp;&amp;<br>        m_priv-&gt;m_incomingMessages.<span class="hljs-built_in">empty</span>() ) &#123;<br>        m_priv-&gt;m_dispatchStatus = DispatchStatus::COMPLETE;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        m_priv-&gt;m_dispatchStatus = DispatchStatus::DATA_REMAINS;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> m_priv-&gt;m_dispatchStatus;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后返回disptch的状态，如果还有消息数据残留，则在<code>dispatch_connections()</code>使用wakeup_thread 唤醒线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StandaloneDispatcher::wakeup_thread</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> to_write = <span class="hljs-string">&#x27;0&#x27;</span>;<br><br>    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">write</span>( m_priv-&gt;process_fd[ <span class="hljs-number">0</span> ], &amp;to_write, <span class="hljs-built_in">sizeof</span>( <span class="hljs-type">char</span> ) ) &lt; <span class="hljs-number">0</span> ) &#123;<br>        <span class="hljs-built_in">SIMPLELOGGER_ERROR</span>( LOGGER_NAME, <span class="hljs-string">&quot;Can&#x27;t write to socketpair?!&quot;</span> );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>wakeup_thread()  在很多需要重复执行 <code>dispatch_thread_main</code>  的地方都用到了，那么是怎么做到的呢。我们需要回到线程函数的中间 <code>wait_for_fd_activity(fds, -1)</code> 。这个函数的作用就是等待给定fds的任何活动，比如读、写。那么执行线程函数的主循环时候，会停在这里等待其他地方对fds进行操作，并不会立刻处理消息的读写，然后再开始进入消息处理的流程。而 wakeup_thread 正是通过向 process_fd 写入一个 ‘0’ 从而达到了唤醒线程的功能。</p><p>至此，第一句语句的大概流程分析完毕，create() 函数的功能就是新建。</p><h3 id="create-connection"><a href="#create-connection" class="headerlink" title="create_connection()"></a>create_connection()</h3><p>然后是 <code>dispatcher-&gt;create_connection(DBus::BusType::SESSION)</code> ，该函数用来创建Connection类实例。很简单，一共只有三句，但这三句都很关键，涉及到很多通信流程的准备和初始化，让我们来一句一句分析。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;DBus::Connection&gt; <span class="hljs-title">StandaloneDispatcher::create_connection</span><span class="hljs-params">( BusType type )</span> </span>&#123;<br>    std::shared_ptr&lt;Connection&gt; conn = Connection::<span class="hljs-built_in">create</span>( type );<br>    conn-&gt;<span class="hljs-built_in">bus_register</span>();<br><br>    <span class="hljs-keyword">if</span>( <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">add_connection</span>( conn ) ) &#123; <span class="hljs-keyword">return</span> conn; &#125;<br><br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;Connection&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>首先第一句 Connection::create() ，利用 create 新建了一个 Connection 类，其构造函数简化如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Connection::<span class="hljs-built_in">Connection</span>( BusType type ) &#123;<br>    m_priv = std::<span class="hljs-built_in">make_unique</span>&lt;priv_data&gt;();<br><br>    <span class="hljs-keyword">if</span>( type == BusType::SESSION ) &#123;<br>        <span class="hljs-type">char</span>* env_address = <span class="hljs-built_in">getenv</span>( <span class="hljs-string">&quot;DBUS_SESSION_BUS_ADDRESS&quot;</span> );<br><br>        <span class="hljs-keyword">if</span>( env_address == <span class="hljs-literal">nullptr</span> ) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        std::string sessionBusAddr = std::<span class="hljs-built_in">string</span>( env_address );<br>        <span class="hljs-built_in">SIMPLELOGGER_DEBUG</span>( LOGGER_NAME, <span class="hljs-string">&quot;Going to open session bus: &quot;</span> + sessionBusAddr );<br>        m_priv-&gt;m_transport = priv::Transport::<span class="hljs-built_in">open_transport</span>( sessionBusAddr );<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-comment">/* 其他 BusType 处理, 此处省略 */</span>)&#123;<br><span class="hljs-comment">/* ... */</span><br>&#125;<br><br>    <span class="hljs-keyword">if</span>( !m_priv-&gt;m_transport || !m_priv-&gt;m_transport-&gt;<span class="hljs-built_in">is_valid</span>() ) &#123;<br>        <span class="hljs-built_in">SIMPLELOGGER_ERROR</span>( LOGGER_NAME, <span class="hljs-string">&quot;Unable to open transport&quot;</span> );<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中需要注意的是 <code>getenv( &quot;DBUS_SESSION_BUS_ADDRESS&quot; )</code>，我们可以在终端输入<code>echo $DBUS_SESSION_BUS_ADDRESS</code> , 获得如下输出，path&#x3D;后面的就是 dbus-daemon 的地址。系统启动脚本中会调用 dbus-launch 来启动一个 dbus-daemon ,同时会把这个 dbus-daemon 赋予这个环境变量中。这个路径是一个socket类型文件。</p><p><img src="https://raw.githubusercontent.com/FreddieGeorge/blogImg/main/img/DBUS_SESSION_BUS_ADDRESS%E5%8F%98%E9%87%8F.png" alt="DBUS_SESSION_BUS_ADDRESS变量"></p><blockquote><p>在我的机器中，系统启动时对该环境变量的设定在 <code>/etc/X11/Xsession.d/20dbus_xdg-runtime</code></p><p><img src="https://raw.githubusercontent.com/FreddieGeorge/blogImg/main/img/%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E5%AF%B9dbus-daemon%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="启动脚本中对dbus-daemon的初始化"></p></blockquote><p>然后再通过  Transport::open_transport 传入这个字符串并返回一个 Transport 类指针，并保存在 <strong>m_transport</strong> 中， 而在这个 Transport 的类中就包含了关键的 writeMessage 和 readMessage 方法，后续的读写操作都是调用这个类指针来完成。</p><p>在 open_transport  函数的开始调用解析函数 parseTransports 对这个字符串进行拆解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;Transport&gt; <span class="hljs-title">Transport::open_transport</span><span class="hljs-params">( std::string address )</span> </span>&#123;<br>    std::vector&lt;ParsedTransport&gt; transports = <span class="hljs-built_in">parseTransports</span>( address );<br>  <span class="hljs-comment">/* ... */</span><br>    <span class="hljs-keyword">if</span>( !path.<span class="hljs-built_in">empty</span>() ) &#123;<br>        fd = <span class="hljs-built_in">open_unix_socket</span>( path, <span class="hljs-literal">false</span> );<br>        <span class="hljs-keyword">if</span>( fd &gt;= <span class="hljs-number">0</span> ) &#123;<br>            retTransport = SendmsgTransport::<span class="hljs-built_in">create</span>( fd, <span class="hljs-literal">true</span> );<br>            <span class="hljs-comment">/* ... */</span><br>&#125;<br>&#125;<br>    <span class="hljs-keyword">if</span>( retTransport ) &#123;<br>        <span class="hljs-function">priv::SASL <span class="hljs-title">saslAuth</span><span class="hljs-params">( retTransport-&gt;fd(), negotiateFD )</span></span>;<br>        std::tuple&lt;<span class="hljs-type">bool</span>, <span class="hljs-type">bool</span>, std::vector&lt;<span class="hljs-type">uint8_t</span>&gt;&gt; resp =<br>                saslAuth.<span class="hljs-built_in">authenticate</span>();<br><br>        retTransport-&gt;m_serverAddress = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;( resp );<br><br>        <span class="hljs-keyword">if</span>( std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;( resp ) == <span class="hljs-literal">false</span> ) &#123;<br>            <span class="hljs-built_in">SIMPLELOGGER_DEBUG</span>( LOGGER_NAME, <span class="hljs-string">&quot;Did not authenticate with server&quot;</span> );<br>            retTransport.<span class="hljs-built_in">reset</span>();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>该函数并不难理解，具体代码自行查看源码，结果就是将上图中的 <code>unxi:path=/run/user/1000/bus</code> 解析为如下( <em>论正则的好处，C++居然还没有引入正则</em>  )，这是DBUS_SECCSION_BUS_ADDRESS 只有一个值的情况，多值情况可以自己结合源码分析一下。</p><blockquote><p>tmpTransportName  &#x3D; “unix”<br>tmpKey &#x3D; “path”<br>tmpValue &#x3D; “&#x2F;run&#x2F;user&#x2F;1000&#x2F;bus”</p></blockquote><p>然后将 tmpKey 和 tmpValue 保存到map对象tmpConfig 中，然后push_back 到retval中并返回。</p><p>知道 parseTransports 函数返回了什么，后面的就好理解了。</p><p>回到 open_transport 函数，后面调用了dbus-cxx 自己实现的 open_unix_socket 打开了这个dbus_daemon 路径，并返回fd，接下来的关键就在于重点就在于 <code>retTransport = SendmsgTransport::create( fd, true );</code> SendmsgTransport 是 Transport 的子类,实际的writeMessage 和 readMessage 方法就是在这里实现的。</p><blockquote><p>在官方文档中这个SendmsgTransport 的介绍是<br>The Sendmsg handles reading and writing over a Unix FD that supports sendmsg(). This allows you to send file descriptors over a Unix FD</p></blockquote><p>回到 open_transport 函数，<code>priv::SASL saslAuth( retTransport-&gt;fd(), negotiateFD )</code> 这句是生成一个 SASL 安全认证，然后与服务器进行身份认证。</p><blockquote><p>SASL:Simple authentication and Security layer</p></blockquote><hr><p>然后是 <code>conn-&gt;bus_register();</code> 对应源码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Connection::bus_register</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>( !m_priv-&gt;m_transport || !m_priv-&gt;m_transport-&gt;<span class="hljs-built_in">is_valid</span>() ) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">is_registered</span>() ) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    m_priv-&gt;m_daemonProxy = DBus::DBusDaemonProxy::<span class="hljs-built_in">create</span>( <span class="hljs-built_in">shared_from_this</span>() );<br><br>    m_priv-&gt;m_uniqueName = m_priv-&gt;m_daemonProxy-&gt;<span class="hljs-built_in">Hello</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数主要新建 DBusDaemonProxy 类指针，使用 <a href="https://yizhi.ren/2016/11/14/sharedptr/">shared_from_this</a> 传递参数，然后在DBusDaemonProxy 构造函数中新建了很多方法，这里也可以看出 dbus-cxx 与 dbus 的联系</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DBusDaemonProxy::<span class="hljs-built_in">DBusDaemonProxy</span>( <span class="hljs-comment">/* ... */</span> ) &#123;<br>    m_method_Hello = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">create_method</span>&lt;std::<span class="hljs-built_in">string</span>()&gt;( <span class="hljs-string">&quot;org.freedesktop.DBus&quot;</span>, <span class="hljs-string">&quot;Hello&quot;</span> );<br><span class="hljs-comment">/* ... */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而 create_method 定义在 <code>objectproxy.h</code> 中，具体作用可以看源码注释</p><blockquote><p>Creates a proxy method with a signature based on the template parameters and adds it to the named interface</p></blockquote><p>然后调用Hello方法返回 unique name 保存在m_priv中，也就是终端输入busctl 显示的那些以 <code>:</code> 开始的名字，这是 DBus 的功能，详情请跳转<a href="https://dbus.freedesktop.org/doc/dbus-specification.html#message-bus-names">链接</a>。</p><hr><p>然后回到 create_connection 中，看到 add_connection 部分，这个函数主要就是把连接加入到 dispatcher 中，可以看到 这个conection获取了 分发线程的线程id，然后还利用push back把connection压入 m_connection 中，最后唤醒线程，在 dispatch_thread_main 中执行连接的分发</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">StandaloneDispatcher::add_connection</span><span class="hljs-params">( std::shared_ptr&lt;Connection&gt; connection )</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>( !connection || !connection-&gt;<span class="hljs-built_in">is_valid</span>() ) &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br><br>    connection-&gt;<span class="hljs-built_in">set_dispatching_thread</span>( m_priv-&gt;m_dispatch_thread.<span class="hljs-built_in">get_id</span>() );<br>    connection-&gt;<span class="hljs-built_in">signal_needs_dispatch</span>().<span class="hljs-built_in">connect</span>( sigc::<span class="hljs-built_in">mem_fun</span>( *<span class="hljs-keyword">this</span>, &amp;StandaloneDispatcher::wakeup_thread ) );<br>    m_priv-&gt;m_connections.<span class="hljs-built_in">push_back</span>( connection );<br>    <span class="hljs-built_in">wakeup_thread</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，create_connection 完毕</p><h3 id="request-name"><a href="#request-name" class="headerlink" title="request_name()"></a>request_name()</h3><p><code>conn-&gt;request_name(&quot;dbuscxx.quickstart_0.server&quot;, DBUSCXX_NAME_FLAG_REPLACE_EXISTING)</code></p><p>request_name 比较简单，也就是获取一个bus名称，直接找到源码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">RequestNameResponse <span class="hljs-title">Connection::request_name</span><span class="hljs-params">( <span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags )</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>( !<span class="hljs-built_in">is_valid</span>() ) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">ErrorDisconnected</span>();<br>    &#125;<br><br>    <span class="hljs-type">uint32_t</span> retval = m_priv-&gt;m_daemonProxy-&gt;<span class="hljs-built_in">RequestName</span>( name, flags );<br><br>    <span class="hljs-keyword">switch</span>( retval ) &#123;<br><br>    <span class="hljs-keyword">case</span> DBUSCXX_REQUEST_NAME_REPLY_PRIMARY_OWNER:<br>        <span class="hljs-keyword">return</span> RequestNameResponse::PrimaryOwner;<br><span class="hljs-comment">/* ... */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重点在于 <code>m_priv-&gt;m_daemonProxy-&gt;RequestName( name, flags )</code>  ，这里调用的是DBus的方法 RequestName ，从DBus 的官方文档中可以看到该方法是用来获取指定的bus名称，根据不同的flags有不同的效果</p><p>更多请参考 <a href="https://dbus.freedesktop.org/doc/dbus-specification.html#message-bus-messages">D-Bus 官方文档</a></p><p>第一部分结束</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DBUS</tag>
      
      <tag>DBUS-CXX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DBUS配置</title>
    <link href="/2023/01/23/DBUS%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/01/23/DBUS%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="DBUS-配置"><a href="#DBUS-配置" class="headerlink" title="DBUS 配置"></a>DBUS 配置</h1><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>建议看这几个官方文档</p><p><a href="https://www.freedesktop.org/wiki/Software/dbus/">dbus (www.freedesktop.org)</a></p><p><a href="https://pythonhosted.org/txdbus/dbus_overview.html">DBus Overview (pythonhosted.org)</a></p><p><a href="https://dbus.freedesktop.org/doc/dbus-tutorial.html">D-Bus Tutorial (dbus.freedesktop.org)</a></p><p><a href="https://dbus.freedesktop.org/doc/dbus-specification.html">D-Bus Specification (dbus.freedesktop.org)</a></p><p><a href="https://www.cnblogs.com/hzl6255/p/4096260.html">DBus介绍 - 北落不吉 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/klb561/p/9058282.html">Dbus组成和原理 - konglingbin - 博客园 (cnblogs.com)</a></p><p><a href="https://www.jianshu.com/p/c073daaf427f">DBUS基础知识 - 简书 (jianshu.com)</a></p><p><a href="https://blog.csdn.net/f110300641/article/details/106823611">DBUS基础知识（非常全面）_土戈的博客-CSDN博客_dbus</a></p><p><a href="http://just4coding.com/2018/07/31/dbus/">D-Bus实例介绍 | Just For Coding (just4coding.com)</a></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><code>D-Bus</code>是<code>Linux</code>及其他类<code>UNIX</code>系统上的一种<code>IPC(Interprocess communication</code>)机制。相较于传统的<code>管道(PIPE)</code>、<code>Socket</code>等原生基于字节流的IPC方式，<code>D-Bus</code>提供了基于独立<code>Message</code>的传输方式，应用程序使用起来更加简单。<code>D-Bus</code>的设计初衷是为<code>Linux</code>桌面环境上的一系列应用程序提供通信方式，它的设计里保留了许多对上层框架设计考虑的元素。</p><p><code>D-Bus</code>的常用架构与传统的<code>Socket</code>一对一通信模式不同，它基于中间消息路由转发的模式来实现, 如下图:</p><p><img src="https://raw.githubusercontent.com/FreddieGeorge/blogImg/main/img/DBUS%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E5%9B%BE.png" alt="DBUS消息转发图"></p><p><code>D-Bus</code>默认提供两种BUS，<code>系统BUS(system)</code>和<code>会话BUS(session)</code>。系统BUS在每台机器上是惟一的，用于后台服务及操作系统之间的通信。会话BUS用于每个登录用户会话的应用程序之间的通信。每个BUS实例由一个<code>bus-daemon</code>进程来管理，由其负责消息路由转发。应用程序需要收发消息，需要连接到BUS实例上。BUS实例使用基于XML的配置文件来控制安全策略，如用户能否注册服务，能给哪些服务接口发送消息等等。</p><h3 id="建立服务流程"><a href="#建立服务流程" class="headerlink" title="建立服务流程"></a>建立服务流程</h3><ul><li><p>建立 dbus 连接 <code>dbus_bus_get()</code></p></li><li><p>为该连接起名 <code>dbus_bus_request_name()</code> ，该名字将作为在后续进行远程调用的时候的服务名</p></li><li><p>进入监听循环 <code>dbus_connection_read_write()</code></p></li><li><p>从总线上取出消息 <code>dbus_connection_pop_message()</code></p></li><li><p>对比消息中的方法接口名和方法名 <code>dbus_message_is_method_call()</code></p></li><li><p>如果一致，则跳转到对应的处理。在处理中，我们会从消息中取出远程调用的参数，并且建立回传结果的通路，<code>reply_to_method_call()</code></p><blockquote><p>回传动作本身等同于一次不需要等待结果的远程调用。</p></blockquote></li></ul><h3 id="发送信号流程"><a href="#发送信号流程" class="headerlink" title="发送信号流程"></a>发送信号流程</h3><ul><li>在建立好 dbus 连接和起名后，可以建立一个发送信号的通道，<code>dbus_message_new_signal()</code> ，在函数中填入该信号的接口名和信号名</li><li>把信号对应的相关参数压进去，<code>dbus_message_iter_init_append()</code>   ，<code>dbus_message_iter_append_basic()</code></li><li>启动发送，<code>dbus_connection_send()</code> ，<code>dbus_connection_flush()</code></li></ul><h3 id="进行远程调用流程"><a href="#进行远程调用流程" class="headerlink" title="进行远程调用流程"></a>进行远程调用流程</h3><ul><li><p>在建立好 dbus 连接和起名后，可以申请一个远程调用通道 <code>dbus_message_new_method_call()</code></p></li><li><p>压入本次调用的参数 <code>dbus_message_iter_init_append()</code>，<code>dbus_message_iter_append_basic()</code></p><blockquote><p>实际上我们是申请了一个首地址，把真正要传的参数，往这个首地址里面送(送完之后一般都会判断是否内存越界了)</p></blockquote></li><li><p>启动发送调用并释放发送相关的消息结构， <code>dbus_connection_send_with_reply()</code>。这个启动函数中带有一个句柄。我们马上会阻塞等待这个句柄给我们带回总线上回传的消息。</p></li><li><p>当这个句柄回传消息之后，我们从消息结构中分离出参数。用dbus提供的函数提取参数的类型和参数 ， <code>dbus_message_iter_init()</code>; <code>dbus_message_iter_next()</code>; <code>dbus_message_iter_get_arg_type()</code>; <code>dbus_message_iter_get_basic()</code>。</p></li></ul><h3 id="信号接收流程"><a href="#信号接收流程" class="headerlink" title="信号接收流程"></a>信号接收流程</h3><ul><li>在建立好 dbus 连接和起名后，为我们将要进行的消息循环添加匹配条件，<code>dbus_bus_add_match()</code></li><li>我们进入等待循环后，只需要对信号名，信号接口名进行判断就可以分别处理各种信号了。在各个处理分支上。我们可以分离出消息中的参数。对参数类型进行判断和其他的处理。</li></ul><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ul><li><code>sudo apt-get install libdbus-glib-1-dev</code></li><li><code>sudo apt-get install libgtk2.0-dev</code></li></ul><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><ol><li>在程序中 <code>#include &lt;dbus/dbus.h&gt;</code> 的时候会报错: <code>dbus/dbus.h ： No such file or directory</code> ，这其实是是 dbus-1.0 的安装位置有问题，在编译时添加 <code>pkg-config --libs --cflags dbus-1</code></li><li><code>dbus/dbus-arch-deps.h ： No such file or directory</code>,在编译时添加 <code>pkg-config --libs --cflags dbus-1</code> 对于1应该也可以通过添加此编译条件解决, 详 <a href="https://www.notion.so/Makefile-8ea3d347262043d6852db7233d0d0aa5">Makefile</a></li></ol><h1 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h1><h3 id="message-h"><a href="#message-h" class="headerlink" title="message.h"></a>message.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> SERVER_BUS_NAME = <span class="hljs-string">&quot;com.flork.dbus&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> OBJECT_PATH_NAME_YES = <span class="hljs-string">&quot;/com/flork/dbus/yes&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> OBJECT_PATH_NAME_NO = <span class="hljs-string">&quot;/com/flork/dbus/no&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> INTERFACE_NAME = <span class="hljs-string">&quot;com.flork.dbus_demo&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> METHOD_NAME = <span class="hljs-string">&quot;hello&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="server-c"><a href="#server-c" class="headerlink" title="server.c"></a>server.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dbus/dbus.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;message.h&quot;</span></span><br><br>DBusError dbus_error;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_dbus_error</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <br>    DBusConnection *conn;<br>    <span class="hljs-type">int</span> ret;<br><br>    <span class="hljs-comment">// 初始化错误信息</span><br>    dbus_error_init(&amp;dbus_error);<br><br>    <span class="hljs-comment">// 建立连接</span><br>    conn = dbus_bus_get(DBUS_BUS_SYSTEM, &amp;dbus_error);<br><br>    <span class="hljs-keyword">if</span>(dbus_error_is_set(&amp;dbus_error))<br>    &#123;<br>        print_dbus_error(<span class="hljs-string">&quot;dbus_bus_get&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(!conn)<br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 为连接起名</span><br>    <br>    ret = dbus_bus_request_name(conn, SERVER_BUS_NAME, <br>DBUS_NAME_FLAG_DO_NOT_QUEUE, &amp;dbus_error);<br><br>    <span class="hljs-keyword">if</span> (dbus_error_is_set(&amp;dbus_error))<br>    &#123;<br>        print_dbus_error(<span class="hljs-string">&quot;dbus_bus_request_name&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (ret != DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;not primary owner, ret = %d\n&quot;</span>, ret);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!dbus_connection_read_write_dispatch(conn,<span class="hljs-number">-1</span>))<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Not connected now.\v&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br><br>        DBusMessage *msg;<br><br>        <span class="hljs-comment">// 从总线上取出消息</span><br>        <span class="hljs-keyword">if</span>((msg = dbus_connection_pop_message(conn)) == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Did not get message\n&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 对比消息中的方法接口名和方法名</span><br>        <span class="hljs-keyword">if</span>(dbus_message_is_method_call(msg,INTERFACE_NAME,METHOD_NAME))<br>        &#123;<br>            <span class="hljs-type">char</span> *s;<br><br>            <span class="hljs-comment">// 获取参数</span><br>            <span class="hljs-keyword">if</span>(dbus_message_get_args(msg,&amp;dbus_error,DBUS_TYPE_STRING,&amp;s,DBUS_TYPE_INVALID))<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received: %s\n&quot;</span>, s);<br><br>                <span class="hljs-comment">// 回复</span><br>                DBusMessage *reply;<br>                <span class="hljs-type">char</span> answer[<span class="hljs-number">1024</span>];<br><br>                assert(reply = dbus_message_new_method_return(msg));<br><br>                DBusMessageIter iter;<br>                <span class="hljs-comment">// 把信号对应的相关参数压进去</span><br>                dbus_message_iter_init_append(reply, &amp;iter);<br><br>                <span class="hljs-keyword">if</span> (dbus_message_has_path(msg, OBJECT_PATH_NAME_YES))<br>                &#123;<br>                    <span class="hljs-built_in">sprintf</span>(answer, <span class="hljs-string">&quot;Yes, %s&quot;</span>, s);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dbus_message_has_path(msg, OBJECT_PATH_NAME_NO))<br>                &#123;<br>                    <span class="hljs-built_in">sprintf</span>(answer, <span class="hljs-string">&quot;No, %s&quot;</span>, s);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-built_in">sprintf</span>(answer, <span class="hljs-string">&quot;No object found&quot;</span>);<br>                &#125;<br><br>                <span class="hljs-type">char</span> *ptr = answer;<br>                assert(dbus_message_iter_append_basic(&amp;iter, DBUS_TYPE_STRING, &amp;ptr));<br><br>                assert(dbus_connection_send(conn, reply, <span class="hljs-literal">NULL</span>));<br>                dbus_connection_flush(conn);<br>                dbus_message_unref(reply);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                print_dbus_error(<span class="hljs-string">&quot;Error getting message&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_dbus_error</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span><br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, str, dbus_error.message);<br>    dbus_error_free(&amp;dbus_error);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="client-c"><a href="#client-c" class="headerlink" title="client.c"></a>client.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctype.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dbus/dbus.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;message.h&quot;</span></span><br><br>DBusError dbus_error;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_dbus_error</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    DBusConnection *conn;<br>    <span class="hljs-type">char</span> input[<span class="hljs-number">80</span>];<br><br>    dbus_error_init(&amp;dbus_error);<br><br>    assert(conn = dbus_bus_get(DBUS_BUS_SYSTEM, &amp;dbus_error));<br><br>    <span class="hljs-keyword">if</span> (dbus_error_is_set(&amp;dbus_error))<br>    &#123;<br>        print_dbus_error(<span class="hljs-string">&quot;dbus_bus_get&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *objects[] = &#123;OBJECT_PATH_NAME_YES, OBJECT_PATH_NAME_NO, <span class="hljs-literal">NULL</span>&#125;;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (; objects[i]; i++)<br>    &#123;<br>        DBusMessage *request;<br>        assert((request = dbus_message_new_method_call(SERVER_BUS_NAME, objects[i], INTERFACE_NAME, METHOD_NAME)));<br><br>        DBusMessageIter iter;<br>        dbus_message_iter_init_append(request, &amp;iter);<br>        <span class="hljs-built_in">snprintf</span>(input, <span class="hljs-keyword">sizeof</span>(input), <span class="hljs-string">&quot;alice&quot;</span>);<br><br>        <span class="hljs-type">char</span> *ptr = input;<br>        assert(dbus_message_iter_append_basic(&amp;iter, DBUS_TYPE_STRING, &amp;ptr));<br><br>        DBusPendingCall *pending_return;<br>        assert(dbus_connection_send_with_reply(conn, request, &amp;pending_return, <span class="hljs-number">-1</span>));<br><br>        assert(pending_return);<br>        dbus_connection_flush(conn);<br>        dbus_message_unref(request);<br><br>        dbus_pending_call_block(pending_return);<br><br>        DBusMessage *reply;<br>        assert((reply = dbus_pending_call_steal_reply(pending_return)));<br>        dbus_pending_call_unref(pending_return);<br><br>        <span class="hljs-type">char</span> *s;<br>        <span class="hljs-keyword">if</span> (dbus_message_get_args(reply, &amp;dbus_error, DBUS_TYPE_STRING, &amp;s, DBUS_TYPE_INVALID))<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Reply: %s\n&quot;</span>, s);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Did not get arguments in reply\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br><br>        dbus_message_unref(reply);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_dbus_error</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span><br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, str, dbus_error.message);<br>    dbus_error_free(&amp;dbus_error);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>:clean</span><br>CFLAG     = `pkg-config --libs --cflags dbus-1`<br><br>SERVER_TARGET = server<br>CLIENT_TARGET = client<br><br><span class="hljs-section">server:</span><br>gcc server.c -o <span class="hljs-variable">$(SERVER_TARGET)</span> <span class="hljs-variable">$(CFLAG)</span><br><br><span class="hljs-section">client:</span><br>gcc client.c -o <span class="hljs-variable">$(CLIENT_TARGET)</span> <span class="hljs-variable">$(CFLAG)</span><br><br><span class="hljs-section">clean:</span><br>rm <span class="hljs-variable">$(SERVER_TARGET)</span> <span class="hljs-variable">$(CLIENT_TARGET)</span><br></code></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>使用 <code>make server</code> 或者 <code>make client</code> 生产可执行文件即可</p><p>直接运行 server 会发现程序报错，Ubunut的安全策略不允许注册服务</p><p>在 <code>/etc/dbus-1/system.d/</code>下创建安全策略文件<code>com.flork.dbus.conf</code>，内容如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">busconfig</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">policy</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&quot;flork&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">allow</span> <span class="hljs-attr">own</span>=<span class="hljs-string">&quot;com.flork.dbus&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">policy</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">policy</span> <span class="hljs-attr">context</span>=<span class="hljs-string">&quot;default&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">allow</span> <span class="hljs-attr">send_interface</span>=<span class="hljs-string">&quot;com.flork.dbus_demo&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">policy</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">busconfig</span>&gt;</span><br></code></pre></td></tr></table></figure><p>再次运行<code>./server &amp;</code>，使用 <code>busctl</code> 可以查看 server 已经创建成功</p><p><img src="https://raw.githubusercontent.com/FreddieGeorge/blogImg/main/img/busctl%E7%BB%93%E6%9E%9C.png" alt="busctl结果"></p><p>之后运行 <code>./client</code> 即可</p><p><img src="https://raw.githubusercontent.com/FreddieGeorge/blogImg/main/img/DBUS%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="DBUS运行结果"></p><h3 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h3><p>仔细检查创建的安全策略文件是否正确！</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DBUS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DBUS-CXX相关配置</title>
    <link href="/2023/01/16/DBUS-CXX%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/01/16/DBUS-CXX%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="DBUS-CXX-配置"><a href="#DBUS-CXX-配置" class="headerlink" title="DBUS-CXX 配置"></a>DBUS-CXX 配置</h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>DBUS-CXX是一个dbus协议基础上提供的C++ api封装。所以我们很多地方可以结合文档和例程直接看源码来进行学习，底层的很多都是linux的官方库。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>需先了解DBUS基础知识，建议看DBUS官方文档</p><p>DBUS-CXX也是建议看官方文档，各个配置环境也先<strong>仔细看对应的文档</strong>再操作</p><p>DBUS-CXX的中文资料较少，耐心看完官方文档</p><p><a href="https://dbus-cxx.github.io/index.html">dbus-cxx: dbus-cxx Library</a></p><p><a href="https://shangenpoden.pixnet.net/blog/post/249943675">[C++]:libsigc++ programming @ 玄根白丁的部落格 :: 痞客邦 :: (pixnet.net)</a></p><h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><h2 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h2><ol><li><p>检查自己是否有cmake并且版本是否大于3.12，若都无，从<a href="https://cmake.org/download/">该网站</a>下载cmake源码</p></li><li><p>解压cmake 源码，之后进入cmake目录执行 <code>sudo ./configure</code>,然后执行<code>sudo make &amp;&amp; make install</code></p></li></ol><h2 id="libsigc"><a href="#libsigc" class="headerlink" title="libsigc++"></a>libsigc++</h2><blockquote><p>从官方文档中可以看到，从压缩包build比git出来的项目更容易，git出来在make的时候会遇到错误</p></blockquote><ol><li><p><code>sudo apt-get install mm-common</code>下载mm-common</p></li><li><p>下载源码 <code>wget https://download.gnome.org/sources/libsigc++/3.0/libsigc%2B%2B-3.0.0.tar.xz</code>  并解压缩，然后进入解压出来的目录</p><blockquote><p>这边选择3.0.0版本，3.2版本利用autotools编译会出现问题，暂时未找到解决方法</p></blockquote></li><li><p><code>mkdir __install</code></p></li><li><p>之后执行<code>./configure  --prefix=$PWD/__install</code>,如果是交叉编译，需要加上<code>--host=xxxx</code></p></li><li><p><code>make &amp;&amp; make install</code> </p></li><li><p>可以看见在__install 下面生成了对应头文件，库文件</p></li></ol><h2 id="dbus-cxx"><a href="#dbus-cxx" class="headerlink" title="dbus-cxx"></a>dbus-cxx</h2><ol><li>下载源码 <code>git clone https://github.com/dbus-cxx/dbus-cxx.git</code></li><li>添加环境变量，指定libsig++安装出来的pkgconfig的位置，该句可以加入你的shell配置文件中<br><code>export PKG_CONFIG_PATH=/home/flork/git/libsigc++-3.0.0/__install/lib/pkgconfig:$PKG_CONFIG_PATH</code></li><li>按照这些步骤安装即可</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir build<br>cd build<br>cmake .. <br>make <br>sudo make install<br></code></pre></td></tr></table></figure><p>编译需要添加指令<code>pkg-config --cflags --libs dbus-cxx-2.0</code>, 详见makefile</p><h1 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h1><blockquote><p>例程来自官方文档例程，详细介绍去文档<a href="https://dbus-cxx.github.io/quick_start_example_0.html">dbus-cxx: Quick start example 0: A simple server and client</a></p></blockquote><h2 id="server-cpp"><a href="#server-cpp" class="headerlink" title="server.cpp"></a>server.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dbus-cxx.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">double</span> param1, <span class="hljs-type">double</span> param2)</span> </span>&#123; <span class="hljs-keyword">return</span> param1 + param2; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;DBus::Dispatcher&gt; dispatcher = DBus::StandaloneDispatcher::<span class="hljs-built_in">create</span>();<br><br>    std::shared_ptr&lt;DBus::Connection&gt; conn = dispatcher-&gt;<span class="hljs-built_in">create_connection</span>(DBus::BusType::SESSION);<br><br>    <span class="hljs-keyword">if</span> (conn-&gt;<span class="hljs-built_in">request_name</span>(<span class="hljs-string">&quot;dbuscxx.quickstart_0.server&quot;</span>, DBUSCXX_NAME_FLAG_REPLACE_EXISTING) != DBus::RequestNameResponse::PrimaryOwner)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// create an object on us</span><br>    std::shared_ptr&lt;DBus::Object&gt; object = conn-&gt;<span class="hljs-built_in">create_object</span>(<span class="hljs-string">&quot;/dbuscxx/quickstart_0&quot;</span>, DBus::ThreadForCalling::DispatcherThread);<br><br>    <span class="hljs-comment">// add a method that can be called over the dbus</span><br>    object-&gt;<span class="hljs-built_in">create_method</span>&lt;<span class="hljs-built_in">double</span>(<span class="hljs-type">double</span>, <span class="hljs-type">double</span>)&gt;(<span class="hljs-string">&quot;dbuscxx.Quickstart&quot;</span>, <span class="hljs-string">&quot;add&quot;</span>, sigc::<span class="hljs-built_in">ptr_fun</span>(add));<br><br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="client-cpp"><a href="#client-cpp" class="headerlink" title="client.cpp"></a>client.cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dbus-cxx.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::shared_ptr&lt;DBus::Dispatcher&gt; dispatcher;<br>    dispatcher = DBus::StandaloneDispatcher::<span class="hljs-built_in">create</span>();<br><br>    std::shared_ptr&lt;DBus::Connection&gt; connection;<br>    connection = dispatcher-&gt;<span class="hljs-built_in">create_connection</span>(DBus::BusType::SESSION);<br><br>    <span class="hljs-comment">// create an object proxy, which stands in for a real object.</span><br>    <span class="hljs-comment">// a proxy exists over the dbus</span><br>    std::shared_ptr&lt;DBus::ObjectProxy&gt; object;<br>    object = connection-&gt;<span class="hljs-built_in">create_object_proxy</span>(<span class="hljs-string">&quot;dbuscxx.quickstart_0.server&quot;</span>, <span class="hljs-string">&quot;/dbuscxx/quickstart_0&quot;</span>);<br><br>    <span class="hljs-comment">// a method proxy acts like a real method, but will go over the dbus</span><br>    <span class="hljs-comment">// to do its work.</span><br>    DBus::MethodProxy&lt;<span class="hljs-built_in">double</span>(<span class="hljs-type">double</span>, <span class="hljs-type">double</span>)&gt; &amp;add_proxy = *(object-&gt;<span class="hljs-built_in">create_method</span>&lt;<span class="hljs-built_in">double</span>(<span class="hljs-type">double</span>, <span class="hljs-type">double</span>)&gt;(<span class="hljs-string">&quot;dbuscxx.Quickstart&quot;</span>, <span class="hljs-string">&quot;add&quot;</span>));<br><br>    <span class="hljs-type">double</span> answer;<br>    answer = <span class="hljs-built_in">add_proxy</span>( <span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span> );<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;1.1 + 2.2 = &quot;</span> &lt;&lt; answer &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp">.PHONY:clean<br><br>CXXFLAG  = -std=c++<span class="hljs-number">17</span> -O3<br>PKGFLAG       = `pkg-config --cflags --libs dbus-cxx<span class="hljs-number">-2.0</span>`<br><br>SERVER_SRC= server.cpp<br>CLIENT_SRC= client.cpp<br><br>SERVER_TARGET   = server<br>CLIENT_TARGET   = client<br><br>all:$(SERVER_TARGET) $(CLIENT_TARGET)<br><br>$(SERVER_TARGET):$(SERVER_SRC)<br>g++ $(CXXFLAG)  $(SERVER_SRC) -o $(SERVER_TARGET) $(PKGFLAG) <br><br>$(CLIENT_TARGET):$(CLIENT_SRC)<br>g++ $(CXXFLAG) $(CLIENT_SRC) -o $(CLIENT_TARGET) $(PKGFLAG)<br><br>clean:<br>@<span class="hljs-keyword">if</span> [ -e <span class="hljs-string">&quot;$(CLIENT_TARGET)&quot;</span> ] ; then \<br>echo <span class="hljs-string">&quot;rm $(CLIENT_TARGET)&quot;</span> ; \<br>rm $(CLIENT_TARGET) ; \<br>fi;<br><br>@<span class="hljs-keyword">if</span> [ -e <span class="hljs-string">&quot;$(SERVER_TARGET)&quot;</span> ] ; then \<br>echo <span class="hljs-string">&quot;rm $(SERVER_TARGET)&quot;</span> ; \<br>rm $(SERVER_TARGET) ; \<br>fi;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>先运行 server ，再运行 client</p><blockquote><p><code>./client</code><br><br> <code>1.1 + 2.2 = 3.3</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DBUS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
